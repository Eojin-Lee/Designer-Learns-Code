<!DOCTYPE html>
<html lang="ko">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Intro | JavaScript</title>
    <!--common css-->
    <link rel="stylesheet" href="styles/common-compressed.css">
  </head>
  <body>
    <header>
      <a id="home" href="https://ujin-lee.github.io/Designer-Learns-Code/JavaScript1.html">Intro to JavaScript</a>
    </header>
    <nav class="sidebar">
      <ul>
        <li class="menu-top"><a href="#intro">JavaScript 소개</a></li>
        <li class="menu-dropdown"><a href="#specification">표준 명세</a></li>
        <li class="menu-top"><a href="#tutorial">튜토리얼</a></li>
        <li class="menu-dropdown"><a href="#comments">명령문</a></li>
        <li class="menu-dropdown"><a href="#expressions">표현식</a></li>
        <li class="menu-dropdown"><a href="#comments">주석</a></li>
        <li class="menu-dropdown"><a href="#console">콘솔</a></li>
        <li class="menu-top"><a href="#variable">변수</a></li>
        <li class="menu-dropdown"><a href="#variableDeclaring">변수 선언</a></li>
        <li class="menu-dropdown"><a href="#variableAssignment">변수 할당</a></li>
        <li class="menu-dropdown"><a href="#hoisting">호이스팅</a></li>
        <li class="menu-top"><a href="#dataTypes">데이터 타입</a></li>
        <li class="menu-dropdown"><a href="#number">숫자</a></li>
        <li class="menu-dropdown"><a href="#string">문자열</a></li>
        <li class="menu-dropdown"><a href="#boolean">불리언</a></li>
        <li class="menu-dropdown"><a href="#nullUndefined">빈값</a></li>
        <li class="menu-top"><a href="#operators">연산자</a></li>
        <li class="menu-dropdown"><a href="#arithmeticOp">산술연산자</a></li>
        <li class="menu-dropdown"><a href="#assignmentOp">할당연산자</a></li>
        <li class="menu-dropdown"><a href="#comparisonOp">비교연산자</a></li>
        <li class="menu-dropdown"><a href="#logicalOp">논리연산자</a></li>
        <li class="menu-top"><a href="#object">객체</a></li>
        <li class="menu-dropdown"><a href="#property">프로퍼티</a></li>
        <li class="menu-dropdown"><a href="#methods">메소드</a></li>
        <!--<li class="menu-dropdown"><a href="#built-inObj">내장객체</a></li>-->
        <li class="menu-top"><a href="#conditionalStm">조건문</a></li>
        <li class="menu-dropdown"><a href="#ifElse">if문</a></li>
        <li class="menu-dropdown"><a href="#switch">switch문</a></li>
        <li class="menu-top"><a href="#functions">함수</a></li>
        <li class="menu-dropdown"><a href="#functionDefinition">함수 정의</a></li>
        <li class="menu-top"><a href="#scope">스코프</a></li>
        <li class="menu-dropdown"><a href="#globalScope">전역 스코프</a></li>
        <li class="menu-dropdown"><a href="#localScope">지역 스코프</a></li>
        <!--<li class="menu-top"><a href="#arrays">배열</a></li>-->
        <!--<li class="menu-top"><a href="#executionContext"></a></li>-->
      </ul>
    </nav>
    <div class="main-wrapper">
      <main class="main-content">
        <article id="intro">
          <h1>JavaScript 소개</h1>
          <p>JavaScript(JavaScript)는 1995년 Netscape Navigator라는 웹 브라우저에 탑재되어 <a href="https://developer.mozilla.org/ko/docs/Web/JavaScript/%EC%96%B8%EC%96%B4_%EB%A6%AC%EC%86%8C%EC%8A%A4">ECMAScript(ES)</a> 라는 이름으로 처음 공개되었습니다. JavaScript는 다른 프로그래밍 언어에 비해 적은 양의 기능을 포함하고 있지만, 웹 브라우저, 웹 서버, 게임 엔진, <a href="https://helpx.adobe.com/kr/photoshop/using/scripting.html" target="_blank">어도비 프로그램</a> 등 다양한 구동 환경과 조합하여 유용한 기능들과 응용 프로그램을 만들 수 있습니다.</p>
          <ul>
            <li><a href="https://developer.mozilla.org/ko/docs/A_re-introduction_to_JavaScript">JavaScript 입문하기 | MDN</a></li>
            <li><a href="https://developer.mozilla.org/ko/docs/Learn/JavaScript/First_steps/What_is_JavaScript">웹 개발에서의 JavaScript 입문하기 | MDN</a></li>
          </ul>
          <section id="specification">
            <h2>표준 명세 Standard Specification</h2>
            <p>표준 명세(Standard Specification)는 프로그래밍 언어의 문법 및 기능을 상세하게 선언한 일종의 프로그래밍 언어 사전입니다. JavaScript의 표준 명세인 <a href="https://developer.mozilla.org/ko/docs/Web/JavaScript/%EC%96%B8%EC%96%B4_%EB%A6%AC%EC%86%8C%EC%8A%A4">ECMAScript(ES)</a>는 1997년에 처음 제정되었고, 2015년에 제정된 <a href="https://jsdev.kr/t/ECMAScript 6/2944">ES2015(ECMAScript 6)</a>이후 표준 명세가 빠르게 업데이트 되고있습니다. 초기의 자바스크는 웹 브라우저 간 표준문법 및 기능이 매우 달라 브라우저 간 호환성이 낮았기 때문에 잘 사용되지 않았습니다. 그러나 1999년 ES3, 2009년 ES5가 나오면서 차츰 호환성 문제가 해결되고, 새로운 문법과 기능들이 추가되면서 JavaScript의 활용도가 이전보다 훨씬 높아지면서 재조명되기 시작했습니다.
            </p>
            <ul>
              <li><a href="http://kangax.github.io/compat-table/es2016plus/" target="_blank">브라우저별 JavaScript 지원 기능 확인하기</a></li>
              <li><a href="https://tc39.github.io/ecma262/" target="_blank">JavaScript의 최신 표준 명세 보러가기</a></li>
            </ul>
          </section>
        </article>
        <article id="tutorial">
          <h1>튜토리얼</h1>
          <p>JavaScript의 문법은 대부분 Java, C, C++로부터 빌려왔습니다. JavaScript에서는 대소문자를 구분하고, Unicode 문자셋을 이용하므로 영어 외의 다양한 언어를 작성할 수 있습니다. 스페이스(space-bar), 탭(tab), 줄바꿈 문자는 공백으로 간주됩니다.</p>
          <p><a href="https://developer.mozilla.org/ko/docs/Web/JavaScript/Guide/Values,_variables,_and_literals#%EA%B8%B0%EB%B3%B8">JavaScript 기본 문법 보기 | MDN</a></p>
          <section id="statements">
            <h2>명령문 Statements</h2>
            <p>프로그램(JavaScript의 스크립트)은 컴퓨터가 단계별로 수행할  명령들의 집합입니다. JavaScript에서 명령은 명령문(statement)으로 부르고, 세미콜론(;)으로 분리합니다. 명령문은 <a href="#variable">var</a>, <a href="#functions">function</a>과 같은 선언 키워드를 사용하여 변수, 함수를 생성하기도 하고 <a href="#ifElse">if</a>, <a href="#">for</a>, <a href="#">while</a> 등의 제어문을 생성하여 프로그램의 흐름을 제어하기도 합니다.</p> 
            <p>명령문은 블록으로 그룹지을 수 있습니다. 블록이란 조건문, 반복문, 함수처럼 특정한 명령을 수행하는 여러개의 명령문들을 중괄호({})로 한데 묶은 코드를 뜻합니다.</p>
            <pre>
              <code>
                var z = x + y;
                /* 
                각각의 명령문이 실행되면 해당 명령에 의해 
                어떠한 일이 발생합니다.
                */

                function getZ(x, y) {
                  return x + y;
                }

                if(x == 1) {
                  // do sth
                }

                for(var i = 0; i < 3; i++) {
                  // do sth
                }
                /* 
                블록문은 여러 명령문을
                중괄호로 묶어놓은 명령문 그룹입니다.
                */</code>
            </pre>
          </section>
          <section id="expressions">
            <h2>표현식 Expressions</h2>
            <p>표현식은 값, 변수, 프로퍼티, 배열 요소, 함수 호출, 메소드 호출, 피연산자와 연산자의 조합 모두를 아우르는 개념으로, 이들은 하나의 값으로 평가(evaluation)됩니다. 하나의 표현식을 다른 표현식의 일부로 적용하여 더욱 복잡한 표현식을 만들 수 있습니다.</p>
            <pre>
              <code>
                x + y
                /* 
                표현식은 하나의 값으로 평가할 수 있습니다.
                */

                var z = x + y;
                /* 
                표현식은 명령문을 구성하는 요소가 될 수 있습니다.
                */</code>
            </pre>
          </section>
          <section id="comments">
            <h2>주석 Comments</h2>
            <p>주석은 공백으로 취급되고 스크립트 실행에서 제외됩니다.</p>
            <pre>
              <code>
                // 이 주석은 한 줄을 작동에서 제외시킵니다.

                /*
                이 주석은 
                여러 줄을 
                작동에서 제외시킵니다.
                */

                하나의 문장에서 /*이 부분만*/ 작동에서 제외시키고 싶을 때에도 쓸 수 있습니다.</code>
            </pre>
            <p>JavaScript에서 주석 처리된 코드는 실제로 작동하지 않지만 사람들은 브라우저 검사기(inspector)나 코드 공유를 할 때 주석을 읽을 수 있습니다. 특히 접근이 쉬운 HTML 파일 안에 script 태그로 JavaScript를 작성한다면 브라우저 검사기를 통해 일반 유저도 쉽게 주석을 볼 수 있습니다.</p>
            <p>그렇지만 너무 많거나 세세한 주석은 오히려 코드를 보기 힘들게 할 수 있습니다. 주석이 없어도 이해할 수 있도록 코드를 명료하게 작성하는 것이 좋습니다.</p>
          </section>
          <section id="console">
            <h2>콘솔 Console</h2>
            <div class="ex">
              <h3>콘솔에 출력하기 console.log()</h3>
              <p>console.log();는 코드의 데이터와 액션을 모두 포함해 선언하는 데이터를 <a href="https://developers.google.com/web/tools/chrome-devtools/console/" target="_blank">브라우저의 Console 창</a>에 출력해서 보여줍니다.</p>
              <pre>
                <code>
                console.log("Hello World"); // "Hello World"
                /* 콘솔에 데이터 출력하기 */

                const name = "Ujin";
                const age = 26;
                const city = "Seoul";
                console.log(name, "/", age, "/", city);

                // "Ujin/26/Seoul"
                /* 콘솔에 여러 데이터를 한 번에 출력하기 */</code>
              </pre>
            </div>
          </section>
        </article>
        <article id="variable">
          <h1>변수</h1>
          <p>어떠한 값을 계속 사용(유지, 캐싱)할 필요가 있다면 그 값을 변수(variable)에 담아 사용할 수 있습니다. 변수는 특정한 값을 저장(할당)하고 저장된 값을 참조하기 위해 사용합니다. 즉, 변수는 특정한 값(value)을 메모리에 담아두고 그 값의 위치(메모리 상의 주소, memory address)에 쉽게 접근하기 위해 사람이 이해할 수 있는 언어로 이름(식별자, identifier)을 붙인 뒤 해당 주소에서 값을 불러오는 역할을 맡습니다. 변수와 변수값을 <a href="#variableDeclaring">선언</a>할 때는 선언 키워드(var, let, const), 식별자(identifier), 할당연산자 = (assignment operator), 값(value)을 할당합니다.</p>
          <pre>
            <code>
                var myName = "Ujin";
                console.log(myName); // "Ujin"

                /*
                var, let, const : 선언 키워드
                myName : 식별자
                = : 할당연산자
                "Ujin" : 값
                */</code>
          </pre>
          <p>식별자(identifier)을 만들 때 알아두어야 할 몇 가지 규칙이 있습니다.</p>
          <ol>
            <li>식별자의 첫글자는 문자, 밑줄(_), 달러 기호($)로 시작해야합니다. 첫글자를 숫자로는 시작할 수 없습니다.</li>
            <li>식별자 안의 대문자와 소문자를 분명히 구분해야 합니다. 같은 식별자에 소문자와 대문자를 다르게 적으면 다른 식별자로 인식됩니다.</li>
            <li>식별자의 첫 단어 이후 다음 단어들은 <a href="http://guswnsxodlf.github.io/camelcase-pascalcase-snakecase" target="_blank">첫 글자를 대문자로 적어줍니다. (camel casing)</a></li>
            <li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Lexical_grammar#Keywords" target="_blank">키워드</a>는 식별자으로 쓸 수 없습니다. 키워드는 표준명세에서 약속된 예약어(resered words)로, 수행할 동작을 미리 규정한 것입니다. 메소드 또한 가져올 수 없습니다.</li>
            <li>함수 식별자(function identifier), 객체 식별자(object identifier)의 이름은 가져올 수 없습니다.</li>
          </ol>
          <section id="variableDeclaring">
            <h2>변수 선언 Variable Declaring</h2>
            <p>기존에는 변수를 선언하기 위해 var 키워드를 사용했지만, var로 변수를 선언한 경우 변수값이 중간에 초기화 되는 등 <a href="https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Strict_mode">엄격한 실행모드(strict mode)</a>에서 <a href="#scopePollution">의도치않은 결과를 출력할 수 있습니다.</a> 따라서 <a href="https://jsdev.kr/t/ECMAScript 6/2944">ECMAScript 6</a> 이후로 새로 등장한 let, const 키워드를 쓰는 것이 권장됩니다.</p>
            <div class="ex" id="variableKeywords">
              <h3>var</h3>
              <p>var로 변수를 선언하면 첫 변수값을 할당한 이후에도 (또는 변수값을 아직 할당하지 않은 경우에도) 기존의 값을 초기화하고 새 값을 할당할 수 있습니다.</p>
              <pre>
                <code>
                var designer = "Ujin";
                console.log(designer); // "Ujin"
                var designer = "Jiyoung";
                console.log(designer); // "Jiyoung"

                var designer;
                console.log(designer); // undefined
                var designer = "Jiyoung"
                console.log(designer); // "Jiyoung"</code>
              </pre>
              <h3>let</h3>
              <p>let도 변수를 선언하면 첫 변수값을 할당한 이후에도 (또는 변수값을 아직 할당하지 않은 경우에도) 기존의 값을 초기화하고 새 값을 할당할 수 있습니다. 그러나 let은 변수값을 다시 할당할 때 var과 달리 변수 앞에 let 키워드를 쓰지 않습니다.</p>
              <pre>
                <code>
                let designer = "Ujin";
                console.log(designer); // "Ujin"
                designer = "Jiyoung";
                console.log(designer); // "Jiyoung"

                let designer;
                console.log(designer); // undefined
                designer = "Jiyoung"
                console.log(designer); // "Jiyoung"

                let designer = "Ujin";
                console.log(designer);
                let designer = "Jiyoung";
                console.log(designer);
                // SyntaxError: Identifier "designer" has already been declared</code>
              </pre>
              <h3>const</h3>
              <p>const로 변수를 선언하면 첫 변수값을 할당한 이후에 새 값을 할당할 수 없고, 변수의 초기값을 반드시 적어야 합니다. 변수값을 중간에 초기화하는 경우가 아니라면 일반적으로 선언 키워드를 const로 사용합니다.</p>
              <pre>
                <code>
                const designer = "Ujin";
                console.log(designer); // "Ujin"
                designer = "Jiyoung"; // TypeError: Assingment to constant variable.

                const designer; // SyntaxError: Missing initializer in const declaration</code>
              </pre>
            </div>
          <section id="variableAssignment">
            <h2>변수 할당 Variable Assignment</h2>
            <p>변수 선언과 동시에 값을 할당할 수 있지만, 변수 선언을 먼저 한 이후에 값을 할당할 수도 있습니다. 할당이 완료되면 이후 변수는 할당받은 값을 대신 내보냅니다.</p>
            <pre>
              <code>
                var myName;
                myName = "Ujin";

                /*
                변수 선언과 동시에 값을 할당하지 않고, 
                선언 이후에 특정 값을 변수에 할당했습니다.
                */</code>
            </pre>
            <p>var, let 선언 키워드를 앞에 둔 변수에 초기값을 할당하지 않았다면 그 변수는 <a href="#nullUndefined">undefined</a> 값을 할당받습니다. 단, 스크립트에 선언된 적 없는 변수에 접근하면 ReferenceError가 발생합니다. <a href="#hoisting">호이스팅 규칙</a>에 의해 var과 let, const는 변수가 선언된 위치에 따라 다른 결과를 출력합니다.</p>
            <pre>
              <code>
                var a;
                console.log("a는 " + a); 
                // "a는 undefined"

                console.log("b는 " + b); 
                var b;
                // "b는 undefined"

                console.log("c는 " + c); 
                // ReferenceError: c is not defiend


                let x;
                console.log("x는 " + x); 
                // "x는 undefined"

                console.log("y는 " + y); 
                let y;
                // ReferenceError: Cannot access "y" before initialization</code>
            </pre>
          </section>
          <section id="hoisting">
            <h2>호이스팅 Hoisting</h2>
            <p>호이스팅 개념은 <a href="https://jsdev.kr/t/ECMAScript 6/2944">ECMAScript 6</a> 이후 등장했습니다. 호이스팅은 '끌어올리기'로 직역할 수 있습니다. 즉, 함수가 작동할 때 함수 안에서 선언된 변수는 선언된 위치에 상관없이 일단 함수 내의 맨 위로 끌어올려지는 것을 뜻합니다. 끌어올려진 변수는 임의의 값으로 undefined를 할당받습니다. 이후 함수가 실행되면서 undefined값을 할당받은 변수가 사용됩니다. 단, 끌어올려진 변수는 사용되거나 다시 선언되거나, 값을 초기화해도 여전히 undefined를 반환합니다.</p>
            <p>호이스팅 규칙에 따라 함수 내의 모든 var 변수는 가능한 함수 위 쪽에 작성하는 것이 좋습니다.</p>
            <pre>
              <code>
                var a = "A";

                function getA() {
                  console.log("a는 " + a); // "a는 undefined"
                  var a = "a";
                  console.log("a는 " + a); // "a는 a"
                }
                getA();
                
                /*
                위 함수는 아래와 같은 과정으로 실행됩니다.
                */

                var a = "A";

                function getA() {
                  var a; // undefined
                  console.log("a는 " + a); // "a는 undefined"
                  var a = "a";
                  console.log("a는 " + a); // "a는 a"
                }
                getA();</code>
            </pre>
            <p>하지만 let, const는 호이스팅을 지원하지 않습니다. let, const로 변수가 선언되기 전에 블록 안에서 변수를 참조하면 ReferenceError가 나타납니다. 이 때 변수는 블록이 시작할 때부터 선언될 때까지 작동하지 않습니다.</p>
            <pre>
              <code>
                let a = "A";

                function getA() {
                  console.log("a는 " + a); 
                  // ReferenceError: Cannot access "A" before initialization
                  let a = "a";
                  console.log("a는 " + a);
                }
                getA();</code>
            </pre>
          </section>
        </article>
        <article id="dataTypes">
          <h1>데이터 타입</h1>
          <p>JavaScript에서 다루는 값은 모두 데이터 타입(Data Types)을 가지고 있습니다. 데이터타입은 프로그래밍 언어에서 사용할 수 있는 값의 종류를 뜻합니다. <a href="https://developer.mozilla.org/ko/docs/Web/JavaScript/Guide/Values,_variables,_and_literals#%EB%8D%B0%EC%9D%B4%ED%84%B0_%EA%B5%AC%EC%A1%B0_%EB%B0%8F_%ED%98%95">JavaScript의 데이터 타입</a>은 기본적으로 7개로 분류합니다. 이 중에서 함수, 배열, 날짜, 정규식은 특별한 종류의 객체 타입으로 구분됩니다.</p>
          <span>원시 타입 Primitive Data Type</span>
          <ol>
            <li><a href="#number">숫자 number</a></li>
            <li><a href="#string">문자열 string</a></li>
            <li><a href="#boolean">불리언 boolean</a></li>
            <li><a href="#nullUndefined">null</a></li>
            <li><a href="#nullUndefined">undefined</a></li>
            <li>심볼 symbol (ECMAScript 6 이후 등장)</li>
          </ol>
          <span>객체 타입 Object Data Type</span>
          <ol>
            <li><a href="#object">객체 object</a></li>
            <li><a href="#functions">함수 function</a></li>
            <li>배열 array</li>
            <li>날짜 date</li>
            <li>정규식 regExp</li>
          </ol>
          <p>JavaScript에서는 변수를 선언할 때 데이터 타입을 따로 지정해주지 않아도 할당된 값의 타입에 의해 자동으로 변수의 타입이 결정됩니다. 이를 동적 타이핑이라 합니다.</p>
          <div class="ex" id="literal">
            <h3>리터럴 literal</h3>
            <p>리터럴은 코드 안에서 직접 만들어낸 상수 값 자체를 뜻하며, 값을 구성하는 최소 단위입니다. 원시 타입 리터럴은 연산자로 연산하여 하나의 값이 될 수 있습니다.</p>
            <pre>
              <code>
                1000101 
                // 숫자 리터럴

                "Hello" 
                // 문자 리터럴

                true 
                // 불리언 리터럴

                null 
                // null 리터럴

                undefined 
                // undefined 리터럴

                { name: "Ujin" city: "Seoul" } 
                // 객체 리터럴

                [1, 2, 3, 4, 5]
                // 배열 리터럴

                /ab+c/
                // 정규표현식 리터럴

                function() {}
                //함수 리터럴
                </code>
            </pre>
          </div>
          <div class="ex" id="typeOf">
            <h3>typeof</h3>
            <p>연산자 typeof는 피연산자(operand)의 데이터 타입을 추출하여 문자열 형태로 반환합니다.</p>
            <pre>
              <code>
                typeof 1; // number
                typeof "hello"; // string
                typeof true; // boolean
                typeof null; // object
                typeof undefined; // undefined

                typeof typeof 1; // string</code>
            </pre>
          </div>
          <section id="number">
            <h2>숫자 Number</h2>
            <p>숫자는 정수, 실수, 0, -0을 포함한 수입니다. 문자열의 형태를 지녔지만 숫자의 개념을 다루는 NaN(Not a Number), Infinity, -Infinity도 숫자 타입입니다.</p>
            <pre>
              <code>
                1, 23.42, -7, 0, -0, NaN, Infinity, -Infinity</code>
            </pre>
            <!--<p>숫자 타입끼리의 계산에는 <a href="#arithmeticOp">산술연산자</a>가 사용됩니다. JavaScript에서 숫자와 문자열 값 사이에 산술연산자 <a href="#addArith">+(add)</a>를 사용해 식을 내면 그 값은 숫자로 반환됩니다. 그 외의 다른 연산자를 포함한 식은 반드시 문자열로 반환하지는 않습니다.</p>
            <pre>
              <code>
                "Answer: " + 38 // "Answer: 38"
                2019 + "번 고객" // "2019번 고객"

                "12" - 3 // 9
                "12" + 3 // 123</code>
            </pre>-->
            <div class="ex" id="convertToNum">
              <h3>Number(), parseFloat(), parseInt()</h3>
              <p>Number(), parseFloat(), parseInt()는 데이터의 첫글자부터 데이터를 숫자 타입으로 변환합니다.<br>데이터의 첫글자가 숫자로 나타낼 수 없는 문자열(알파벳, 공백 등)이라면 NaN을 출력합니다.</p>
              <pre>
                <code>
                const a = "10"; // 정수
                const b = "2.019"; // 소수점이 있는 실수
                const c = "3a"; // 정수 + 알파벳
                const d = "3.4 5.6 7.8" // 소수점이 있는 실수 + 공백
                const e = "40 sec" // 정수 + 공백 + 알파벳
                const f = "Hi 2019" // 알파벳 + 공백 + 정수

                Number(a); // 10
                Number(b); // 2.019
                Number(c); // NaN
                Number(d); // NaN
                Number(e); // NaN
                Number(f); // NaN

                /* 
                Number()는 
                숫자로 나타낼 수 없는 문자열이 포함되어있으면 
                NaN을 출력합니다.
                */

                parseFloat(a); // 10
                parseFloat(b); // 2.019
                parseFloat(c); // 3
                parseFloat(d); // 3.4
                parseFloat(e); // 40
                parseFloat(f); // NaN

                /* 
                parseFlaot()는 
                숫자로 나타낼 수 없는 문자열이 포함되어있으면 
                그러한 문자열을 제외한 뒤 앞글자부터 출력합니다. 
                그러한 문자열이 첫글자일 경우 NaN을 출력합니다.
                */

                parseInt(a); // 10
                parseInt(b); // 2
                parseInt(c); // 3
                parseInt(d); // 3
                parseInt(e); // 40
                parseInt(f); // NaN

                /* 
                parseInt()는 
                숫자로 나타낼 수 없는 문자열이 포함되어있으면 
                그러한 문자열을 제외한 뒤 앞글자부터 소수점을 지우고 정수(integer)로만 출력합니다. 
                그러한 문자열이 첫글자일 경우 NaN을 출력합니다.
                */</code>
              </pre>
            </div>
            <div class="ex" id="math">
              <h3>Math()</h3>
              <p>Math()는 수학적인 상수와 함수를 간단한 식으로 나타내거나 변환할 수 있는 <!--<a href="#built-inObj">-->내장객체<!--</a>-->입니다.</p>
              <pre>
                <code>
                Math.E(); // 자연상수 e (2.71...)
                Math.PI(); // 원주율 (3.14...)

                Math.sin(); // 사인
                Math.cos(); // 코사인
                Math.tan(); // 탄젠트
                Math.log(); // 밑을 자연상수로 두는 로그함수
                Math.exp(); // 밑을 자연상수로 두는 지수함수
                Math.sqrt(); // 제곱근
                
                Math.abs(); // 절댓값
                Math.ceil(); // 소수점 이하 올림
                Math.floor(); // 소수점 이하 내림
                Math.round(); // 소수점 이하 반올림
                Math.trunc(); // 소수점 이하 잘라내기

                Math.max(); // 최댓값
                Math.min(); // 최소값

                Math.random(); // 랜덤값</code>
              </pre>
            </div>
          </section>
          <section id="string">
            <h2>문자열 String</h2>
            <p>문자열은 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Text_formatting" target="_blank">"..."(single quotes) 또는 "..."(double quotes)</a> 안에 둘러싸인 모든 글자, 숫자, 공백, 심볼 등을 포함합니다. Console.log로 문자열을 출력하면 "..."로 출력됩니다.</p>
            <pre>
              <code>
                "This is String!", "문자열은", "이러한 형태입니다."</code>
            </pre>
            <div class="ex" id="templateLiterals">
              <h3><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals" target="_blank">템플릿 문자열 Template Literals</a></h3>
              <p><a href="https://jsdev.kr/t/ECMAScript 6/2944">ECMAScript 6</a> 이후 등장한 템플릿 문자열로 문자열을 간단하게 반환하고 채워넣을 수 있습니다. 템플릿 문자열은 "",""이 아닌 ``(backticks, 키보드의 1!키 왼쪽에 있는 키)로 둘러싸입니다. 반환될 문자열 변수를 ${} 안에 넣으면 해당되는 변수값이 출력됩니다.</p>
              <pre>
                <code>
                const name = "Jiyeong";
                const age = 37;
                const city = "Busan";
                console.log(`Hi, My name is ${name}. 
                I"m ${age} now. 
                And I"m from ${city}.`);

                /*
                "Hi, My name is Jiyeong. 
                I"m now 37. 
                And I"m from Busan."
                */</code>
              </pre>
            </div>
            <div class="ex" id="stringWorks">
              <h3>.length</h3>
              <p>문자열의 길이(개수)값, 또는 배열의 요소 개수를 반환합니다.</p>
              <pre>
                <code>
                const weather = "2019.04.14 Today: 날씨 맑음!!"
                weather.length; // 25</code>
              </pre>
              <h3>charAt(n), indexOf(), substring(n1, n2)</h3>
              <p>각각 n번째 문자열, 특정 문자열의 순서(n번째), n1번째부터 n2번째까지의 문자열을 반환합니다.</p>
              <pre>
                <code>
                const weather = "2019.04.14 Today: 날씨 맑음!!"

                weather.charAt(6); // 4
                weather[6]; // 4
                weather.indexOf("날"); // 18
                weather.substring(0, 4); // 2019</code>
              </pre> 
              <h3>toUpperCase(), startsWith()</h3>
              <p>각각 문자열을 대문자로 반환하고, 전체 문자열이 해당 문자열로 시작하는지 알려주는 진리값을 반환합니다.</p>
              <pre>
                <code>
                const weather = "2019.04.14 Today: 날씨 맑음!!"

                weather.toUpperCase(); // "2019.04.14 TODAY: 날씨 맑음!!"
                weather.startsWith("2019.04"); // true</code>
              </pre>  
            </div>
            <div class="ex" id="convertToStr">
              <h3>String()</h3>
              <p>변수의 타입을 문자열로 변환합니다. null, undefined값도 변환할 수 있습니다.</p>
              <pre>
                <code>
                const x = 1;
                const y = 2;
                let z;

                x + y; // 3
                String(x) + String(y); // "12"
                String(z); // "undefined"</code>
              </pre>
            </div>
          </section>
          <section id="boolean">
            <h2>불리언 Boolean</h2>
            <p>불리언은 데이터에 대한 조건이 참 또는 거짓(true or false, yes or no)을 나타냅니다. 이 조건을 불리언값 또는 진리값이라 부릅니다. 주로 서로 다른 데이터값의 일치 여부를 확인하기 위해 다양한 <a href="#operators">연산자</a>와 함께 사용합니다.</p>
            <pre>
              <code>
                1 === 1 // true
                1 === 2 // false</code>
            </pre>
            <div class="ex" id="truthyFalsy">
              <h3>불리언이 아닌 데이터 타입의 진리값 Truthy & Falsy</h3>
              <p>데이터 타입이 정확히 불리언은 아니지만 거짓으로 판정되는 값을 falsy값이라 부르고, 나머지 값을 truthy값이라 부릅니다. JavaScript는 아래의 데이터 타입을 falsy 값으로 판단합니다.</p>
              <ol>
                <li>false (boolean)</li>
                <li>null (null-object)</li>
                <li>undefined (undefined)</li>
                <li>0 (number)</li>
                <li>NaN (number)</li>
                <li>"" (string)</li>
                <li>document.all (object)</li>
              </ol>
            </div>
            <div class="ex" id="arithmeticOpTF">
              <h3><a href="#arithmeticOp">산술연산자</a>로 진리값 확인하기</h3>
              <p>진리값을 산술연산자로 계산할 때 true(truthy)는 숫자 1, false(falsy)는 숫자 0으로 변환되어 계산됩니다.</p>
              <pre>
                <code>
                const x = true;
                const y = false;

                0 + x; // 1 
                0 + y; // 0
                "" + x; // true
                "" + y; // false
                false + x; // 1
                false + y; // 0
                null + x; // 1
                null + y; // 0
                undefined + x; // NaN
                undefined + y; // NaN</code>
              </pre>
            </div>
          </section>
          <section id="nullUndefined">
            <h2>빈값 Null & Undefined</h2>
            <p>null(no value)과 undefined 모두 값이 없음을 나타내지만, 뜻이 약간  다릅니다. null은 "객체 값이 존재하지 않음"을 나타내고, undefined는 "아직 값을 할당한 적이 없음"을 나타냅니다. 그래서 typeof로 null을 반환하면 object로, undefined를 반환하면 undefined로 출력됩니다.</p>
            <pre>
              <code>
                typeof null; // object
                typeof undefined; // undefined</code>
            </pre>
            <div class="ex" id="nullUndefinedCheck">
              <h3>빈값 체크 Null & Undefiend Check</h3>
              <p><a href="#ifElse">if문</a>과 <a href="#typeOf">typeof</a>를 사용해서 변수값이 비어있는지(초기화되어있는지, 또는 할당된 적이 없는지) 확인할 수 있습니다. if문의 매개변수(parameter) 값은 진리값을 반환하므로 매개변수로 쓰인 변수값이 <a href="#truthyFalsy">truthy or falsy</a>값을 반환하면 빈값 여부를 알 수 있습니다.</p>
              <pre>
                <code>
                if (value) {
                  // value가 truthy라면 빈값이 아닙니다. (falsy 값입니다.)
                }</code>
              </pre>
              <p>어떠한 변수가 선언된 적이 있는지 잘 모를 때, 즉 변수가 이전에 선언된 적이 있는지 확인하고 싶을 때는 매개변수 안에 typeof 연산자를 추가한 뒤 엄격한 비교를 통해 undefined인지 확인합니다.<a href="http://typeofnan.blogspot.com/2011/01/typeof-is-fast.html">특히 undefined 체크에서 typeof 연산자를 사용하면 속도가 향상될 수 있다고 합니다.</a></p>
              <pre>
                <code>
                if (typeof value !== "undefined") {
                  // value의 타입이 undefined가 아니라면 value값은 선언된 적이 있습니다.
                }</code>
              </pre>
              <p>그런데 우리가 빈값이라고 생각하는 데이터타입이 null 또는 undefined가 아닌 경우가 많습니다. 아래에 헷갈릴 수 있는 데이터타입들을 모아봤습니다.</p>
              <pre>
                <code>
                typeof(); //undefined
                typeof(null); //null
                typeof(NaN); //number
                typeof(0); //number
                typeof({}); //object
                typeof([]); //array
                typeof(''); //string
                typeof(function () {}); //function
                typeof(/a/) //regexp
                typeof(new Date()) //date
                typeof(new WeakMap()) //weakmap
                typeof(new Map()) //map</code>
              </pre>
            </div>
          </section>
        </article>
        <article id="operators">
          <h1>연산자</h1>
          <p>JavaScript에서 주로 쓰이는 연산자는 아래와 같습니다.</p>
          <ol>
            <li><a href="#arithmeticOp">산술연산자</a></li>
            <li><a href="#assignmentOp">할당연산자</a></li>
            <li><a href="#comparisonOp">비교연산자</a></li>
            <li><a href="#logicalOp">논리연산자</a></li>
          </ol>
          <section id="arithmeticOp">
            <h2>산술연산자 Arithmetic Operators</h2>
            <p>산술연산자는 마치 계산기처럼 주로 간단한 숫자 계산을 할 때 사용하는 연산자입니다. 산술연산자는 숫자, 문자열, 또는 변수(variables)를 피연산자(operators)로 넣을 수 있고, 그 결과값을 숫자 또는 문자열로 반환합니다. 피연산자의 타입과 연산자의 종류에 따라 결과값의 타입이 달라집니다. 따라서 연산 전에 피연산자를 미리 <a href="#convertToNum">숫자로 변환</a>해두어야 일관적인 결과값을 얻을 수 있습니다.</p>
            <pre>
              <code>
                2 + 3 - 1; // 4
                5 * 3 / 2; // 15 / 2 
                // 7.5
                11 % 2 ** 3; // 11 % 8
                // 3</code>
            </pre>
            <div class="ex" id="addArith">
              <h3>덧셈 + Addition</h3>
              <p>덧셈은 숫자 뿐만아니라 다양한 데이터 타입끼리의 연산이 가능합니다. 문자열과 숫자를 연결할 때(Concatenation) 또는 문자열끼리 연결할 때, 그리고 진리값끼리 연산할 때에도 덧셈을 사용할 수 있습니다.</p>
              <pre>
                <code>
                0 + 1; // 1 
                0 + true; // 1 
                false + false; // 0 

                "Hi" + 5; // "Hi5"
                "Hi" + false; // "Hifalse"
                "Hi" + "Five"; // "HiFive"</code>
              </pre>
            </div>
            <div class="ex" id="subtArith">
              <h3>뺄셈 - Subtraction</h3>
              <p>뺄셈은 데이터끼리의 차이를 출력합니다. 덧셈을 제외한 나머지 산술연산에서는 문자열을 포함한 결과값이 NaN으로 출력됩니다.</p>             
              <pre>
                <code>
                0 - 1; // -1 
                0 - true; // -1 
                true - false; // 1 

                "Hi5" - 5; // NaN
                "Hifalse" - false; // NaN
                "HiFive" - "Five"; // NaN</code>
              </pre>
            </div>
            <div class="ex" id="multiArith">
              <h3>곱셈 * Multiplication</h3>
              <pre>
                <code>
                1 * 2; // 2
                1 * -2; // -2
                1 * 0; // 0
                Infinity * 0; // NaN
                Infinity * Infinity; // Infinity</code>
              </pre>
            </div>
            <div class="ex" id="divideArith">
              <h3>나눗셈 / Division</h3>
              <pre>
                <code>
                1 / 2; // 0.5
                1.0 / 2.0; // 0.5
                0 / 2; // 0
                2 / 0; // Infinity
                2.0 / 0.0; // Infinity
                2 / -0; // -Infinity</code>
              </pre>
            </div>
            <div class="ex" id="moduloArith">
              <h3>나머지 % Modulo(Remainder)</h3>
              <pre>
                <code>
                12 % 5; // 2
                1 % 2; // 1 
                -1 % 2; // -1
                1 % -2; // 1
                2 % 2; // 0
                -2 % 2; // -0
                0 % 2; // 0
                2 % 0; // NaN
                NaN % 2; // NaN
                5.5 % 2; // 1.5</code>
              </pre>
            </div>
            <div class="ex" id="exponentArith">
              <h3>거듭제곱 ** Exponentiation</h3>
              <p>JavaScript에서 거듭제곱을 사용할 때는 괄호 등으로 양음수 여부나 계산 순서를 명확히 해주어야 합니다.</p>
              <pre>
                <code>
                2 ** 3; // 8
                -2 ** 3; // Invalid
                -(2 ** 3); // -8
                (-2) ** 3; // 8

                3 ** 2.5 // 15.588457268119896
                10 ** -1 // 0.1
                NaN ** 2 // NaN

                2 ** 2 ** 3; // 128
                2 ** (2 ** 3) // 128
                (2 ** 2) ** 3 // 64</code>
              </pre>
            </div>
            <div class="ex" id="incre_decrementArith">
              <h3>증가 ++, 증감 -- Increment, Decrement</h3>
              <p>증가, 증감 연산자는 피연산자1의 뒤에 붙으면 피연산자2의 값을 계산 전 값으로 반환하고, 피연산자1의 앞에 붙으면 피연산자2의 값을 계산 후 값으로 반환합니다.</p>
              <pre>
                <code>
                let x = 5;
                y = x++; // x = 6, y = 5
                y = x--; // x = 4, y = 5
                // 연산자가 피연산자의 뒤에 붙었을 때

                let a = 5;
                b = ++a; // a = 6, b = 6
                b = --a; // a = 4, b = 4
                // 연산자가 피연산자의 뒤에 붙었을 때</code>
              </pre>
            </div>
          </section>
          <section id="assignmentOp">
            <h2>할당연산자 Assignment Operators</h2>
            <p>할당연산자는 연산자 기준으로 오른쪽 피연산자의 값을 왼쪽의 피연산자에 할당합니다.</p>
            <pre>
              <code>
                let a = 10;
                let b = 20;
                let c = 100;
                let d = 2000;
                let e = 45;

                a += 5; // 15
                b -= 30; // -10
                c *= 8; // 800
                d /= 50; // 40
                e %= 8; // 5</code>
            </pre>
            <div class="ex" id="equalAssign">
              <h3>할당 = Assignment</h3>
              <p>한 개의 값을 여러개의 변수에 할당하기 위해 할당 연산자를 연속으로 사용할 수 있습니다.</p>
              <pre>
                <code>
                let x = 5;
                let y = 10;
                let z = 25;

                x = y; // x = 10;</code>
              </pre>
            </div>
            <div class="ex" id="addAssign">
              <h3>덧셈 할당 += Addition Assignment</h3>
              <p>두개의 피연산자 데이터 타입에 따라 숫자의 덧셈 또는 문자열의 연결이 가능합니다.</p>
              <pre>
                <code>
                let str = "string";
                let num = 5;
                let boo = true;

                num += 2; // 7
                boo += 2; // 3
                boo += false; // 1
              
                num += "foo"; // "5foo"
                str += false; // "stringfalse"
                str += "foo"; // "stringfoo"</code>
              </pre>
            </div>
            <div class="ex" id="subtAssign">
              <h3>뺄셈 할당 -= Subtraction Assignment</h3>
              <pre>
                <code>
                let str = "string";
                let num = 5;
                let boo = true;

                num -= 2; // 3
                boo -= 2; // -1
                str -= 2; // NaN</code>
              </pre>
            </div>
            <div class="ex" id="multiAssign">
              <h3>곱셈 할당 *= Multiplication Assignment</h3>
              <pre>
                <code>
                let str = "string";
                let num = 5;
                let boo = true;

                num *= 2; // 10
                boo *= 2; // 2
                str *= 2; // NaN</code>
              </pre>
            </div>
            <div class="ex" id="divideAssign">
              <h3>나눗셈 할당 /= Division Assignment</h3>
              <pre>
                <code>
                let str = "string";
                let num = 5;
                let boo = true;

                num /= 2; // 2.5
                boo /= 2; // 0.5
                str /= 2; // NaN
                num /= 0; // Infinity</code>
              </pre>
            </div>
            <div class="ex" id="moduloAssign">
              <h3>나머지 할당 %= Modulo(Remainder) Assignment</h3>
              <pre>
                <code>
                let str = "string";
                let num = 5;
                let boo = true;

                num %= 2; // 1
                boo %= 2; // 1
                str %= 2; // NaN
                num %= 0; // Infinity</code>
              </pre>
            </div>
          </section>
          <section id="comparisonOp">
            <h2>비교연산자 Comparison Operators</h2>
            <p>서로 다른 두 값을 비교할 때 사용하는 비교연산자는 두 종류, 엄격한 비교(strict comparison)와 형변환 비교(abstract comparison)로 나뉩니다. 엄격한 비교는 피연산자끼리 동일한 값과 데이터타입을 가져야만 true를 출력하고, 형변환은 비교 전 피연산자들을 같은 자료형으로 바꾼 뒤 엄격한 비교를 진행합니다.<br>엄격한 비교연산자는 형변환 비교연산자의 뒤에 = 하나를 더 붙입니다.</p>
            <div class="ex" id="equalityIdentity">
              <h3>동등 ==, 일치 === Equality, Identity</h3>
              <p>피연산자 둘 다 객체라면, 객체 내부 내용을 비교한 뒤 엄격한 비교를 진행합니다. 단, null과 undefined는 엄격한 비교로서는 다르지만, 형변환 비교로는 같습니다.</p>
              <pre>
                <code>
                1 == 1
                "1" == 1
                0 == false // true

                0 == null
                0 == undefined // false

                1 === 1 // true
                1 === "1" // false

                null == undefined // true
                null === undefined // false</code>
              </pre>
            </div>
            <div class="ex" id="inequalityNonIdentity">
              <h3>부등 !=, 불일치 !== inequality, Non-Identity</h3>
              <pre>
                <code>
                1 != 2
                0 != true // true

                "1" != 1
                0 != false // false

                1 !== 2 // true
                "1" !== 1 // true</code>
              </pre>
            </div>
            <div class="ex" id="relationalOp">
              <h3>관계 >, <, >=, <= Relational Operators</h3>
              <pre>
                <code>
                3 > 3 
                3 < 3 // false

                3 >= 3
                3 <= 3 // true</code>
              </pre>
            </div>
          </section>
          <section id="logicalOp">
            <h2>논리연산자 Logical Operators</h2>
            <p>논리연산자는 진리값을 가진(또는 truthy & falsy 값을 반환하는) 두 피연산자의 집합을 관계지은 뒤, 주로 진리값 또는 다른 데이터형으로 출력합니다. 논리연산자가 포함된 논리표현식은 왼쪽부터 오른쪽 방향으로 진행됩니다.</p>
            <div class="ex" id="logicalAnd">
              <h3>&& AND</h3>
              <p>피연산자1이 false로 변환되면 피연산자1을 반환하고 표현식 진행을 종료합니다. 그렇지 않으면 피연산자2를 반환합니다.</p>
              <pre>
                <code>
                true && true // true (피연산자2)
                true && false // false 
                false && true // false 
                /*
                피연산자 둘 다 불리언 타입인 경우
                */

                false && (3 === 4) // false (피연산자1)
                /*
                피연산자 중 하나가 불리언 타입일 경우
                */

                "A" && "B" // "B"
                false && "B" // false (피연산자1)
                "A" && false // false (피연산자2)
                /*
                피연산자 중 하나가 불리언 타입이고, 
                다른 하나는 문자열인 경우
                */

                "" && false // "" (피연산자1)
                false && "" // false (피연산자1)
                /*
                피연산자 중 하나가 불리언 타입이고, 
                다른 하나는 빈 문자열인 경우
                */</code>
              </pre>
            </div>
            <div class="ex" id="logicalOr">
              <h3>|| OR</h3>
              <p>피연산자1이 true로 변환되면 피연산자1을 반환하고 표현식 진행을 종료합니다. 그렇지 않으면 피연산자2를 반환합니다.</p>
              <pre>
                <code>
                true || true // true (피연산자1)
                true || false // true 
                false || true // true
                /*
                피연산자 둘 다 불리언 타입인 경우
                */

                false || (3 === 4) // false (피연산자2)
                /*
                피연산자 중 하나가 불리언 타입일 경우
                */

                "A" || "B" // "A" (피연산자1)
                false || "B" // "B"
                "A" || false // "A"
                /*
                피연산자 중 하나가 불리언 타입이고, 
                다른 하나는 문자열인 경우
                */

                "" || false // false (피연산자2)
                false || "" // "" (피연산자2)
                /*
                피연산자 중 하나가 불리언 타입이고, 
                다른 하나는 빈 문자열인 경우
                */
                </code>
              </pre>
            </div>
            <div class="ex" id="logicalNot">
              <h3>!, !! NOT, Double NOT</h3>
              <p>Not은 단일 피연산자가 true로 변환되면 false를 반환합니다. 그렇지 않으면 true를 반환합니다. Double Not은 반대로 피연산자의 진리값을 그대로 반환합니다.</p>
              <pre>
                <code>
                !true // false
                !false // true
                !"" // true
                !"A" // false

                !!true // true
                !!false // false
                !!"" // false
                !!"A" // true</code>
              </pre>
            </div>
            <div class="ex" id="logicalExprShortC">
              <h3>논리표현식 단락 평가 Logical Expressions Short-circuit</h3>
              <p>논리연산자를 사용하는 논리표현식은 왼쪽부터 오른쪽 방향으로 진행되므로, 피연산자1에서 표현식 진행이 마무리 되면 다음 피연산자2를 계산할 필요가 없습니다. 따라서 되도록 계산을 빨리하기 위해 피연산자1만 계산하도록 하는 단락 평가를 수행합니다.</p>
              <pre>
                <code>
                function getA() {
                  console.log("A는 1");
                  return false;
                }
                function getB() {
                  console.log("B는 2");
                  return true;
                }

                console.log( getA() && getB() );
                // "A는 1"
                // false

                console.log( getB() || getA() );
                // "B는 2"
                // true
                
                /*
                논리표현식에서 피연산자1에서 계산이 완료되어 
                피연산자2를 계산하지 않음
                */</code>
              </pre>
            </div>
          </section>
        </article>
        <article id="object">
          <h1>객체</h1>
          <p>객체(object)는 마치 컨테이너 박스처럼 한꺼번에 여러 값을 담을 수 있는 구조를 지닌 데이터 타입입니다. JavaScript의 객체는 키(이름)와 값으로 구성된 <a href="#property">프로퍼티(property)의 집합입니다. 객체는 각각 데이터와 액션의 역할을 수행하는 프로퍼티와 메소드를 모두 포함할 수 있기 때문에 이들을 각각이 아닌 하나의 단위로 구조화할 수 있습니다.</a></p>
          <pre>
            <code>
                const weather = {
                  city: "Seoul"
                  temperature: "20" + "℃"
                  todayWeather: function() {
                    console.log(this.city + " is " + this.temperature + " today.");
                  }
                }   
                
                /*
                weather는 객체의 이름입니다.
                weather의 프로퍼티는 city, temperature, todayWeather 이고
                todayWeather는 메소드입니다.
                */</code>
          </pre>
          <section id="property">
            <h2>프로퍼티 Property</h2>
            <p>프로퍼티는 객체에서 변수처럼 이름 붙여지는 객체의 데이터들입니다. 객체의 이름(name) 뒤에 .(점 연산자, dot operator)를 쓰고 프로퍼티를 붙입니다. JavaScript에서 사용할 수 있는 모든 값은 프로퍼티가 될 수 있습니다.</p>
            <pre>
              <code>
                const weather = {
                  city: "Seoul"
                  temperature: "20" + "℃"
                  todayWeather: function() {
                    console.log(this.city + " is " + this.temperature + " today.");
                  }
                }   
                
                /*
                프로퍼티는 객체의 데이터를 뜻합니다.
                this 뒤에 weather의 프로퍼티가 사용되었습니다.
                */</code>
            </pre>
          </section>
          <section id="methods">
            <h2>메소드 Methods</h2>
            <p>객체에서 쓰이는 프로퍼티 값이 함수일 경우 일반 함수와 구분하기 위해 메소드라고 부릅니다. 메소드는 프로퍼티의 역할을 하기 때문에 프로퍼티처럼 객체의 이름 뒤에 .(점 연산자)를 쓴 뒤 메소드를 붙입니다.</p>
            <pre>
              <code>
                const weather = {
                  city: "Seoul"
                  temperature: "20" + "℃"
                  todayWeather: function() {
                    console.log(this.city + " is " + this.temperature + " today.");
                  }
                }   
                weather.todayWeather(); // "Seoul is 20℃ today."</code>
            </pre>
          </section>
          <!--<section id="built-inObj">
            <h2>내장객체 Built-in Objects</h2>
            <p>개발자가 새로운 객체를 직접 만들고 이름붙일 수 있지만, JavaScript에는 이미 내장된 객체들이 많이 있습니다.</p>
          </section>-->
        </article>
        <article id="conditionalStm">
          <h1>조건문</h1>
          <section id="ifElse">
            <h2>if문</h2>
            <p>if문은 미리 지정된 변수를 자식개체로 삼아 ()에 넣고, 자식개체의 진리값(true & false, truthy & falsy)에 따라 어떤 행동을 출력할 지 중괄호({})에 적어냅니다. if문의 a값이 참이면 첫 번째 행동을, 거짓이면 else에 적힌 두 번째 행동을 출력합니다. 중간에 else if()를 추가해 조건을 여러 개 걸어놓을 수 있습니다.</p>
            <pre>
              <code>
                let a = true;

                if (a) {
                  console.log("a is true!");
                } else if(a == 0) {
                  console.log("a is zero!");
                } else {
                  console.log("a is false!")
                }

                // "a is true!"</code>
            </pre>
            <div class="ex" id="truthyFalsyAssignment">
              <h3>논리연산자를 이용한 조건문 Truthy & Falsy Assignment</h3>
              <p><a href="#logicalOr">논리연산자 ||(or)</a>를 사용해 조건문을 만들 수 있습니다. ||는 왼쪽에서부터 오른쪽으로 진행되면서 true값을 반환합니다.</p>
              <pre>
                <code>
                let name = "";
                let userId = name || "익명의 사용자";

                console.log(`${userId}님이 로그인 하셨습니다.`);
                // "익명의 사용자님이 로그인하셨습니다."

                name = "Ujin";
                userId = name || "익명의 사용자";
                
                console.log(`${userId}님이 로그인 하셨습니다.`);
                // "Ujin님이 로그인하셨습니다."</code>
              </pre>
            </div>
            <div class="ex" id="ternaryOp">
              <h3>삼항 연산자 ternary Operator</h3>
              <p>삼항 연산자는 세 개의 피연산 함수를 쓸 수 있는 연산자입니다. 조건이 true이면 ? 피연산자1을, : 아니라면 피연산자2를 반환합니다.</p>
              <pre>
                <code>
                let name = "";
                let userId = name || "익명의 사용자";

                name ? console.log(`${userId}님, 안녕하세요!`) : console.log(`로그인이 필요합니다.`);</code>
              </pre>
            </div>
          </section>
          <section id="switch">
            <h2>switch문</h2>
            <p>조건문의 조건이 단일의 숫자나 문자열처럼 비교적 단순한 구조라면 switch문으로 더욱 간단하게 표현할 수 있습니다. switch문에서는 각 조건(case)이 끝날 때마다 break;를 반드시 써야합니다.</p>
            <pre>
              <code>
                let name = "";
                let weather;

                switch (weather) {
                  case "sunny":
                    console.log("Great to walk!");
                    break;
                  case "gloomy":
                    console.log("Not so bad.");
                    break;
                  case "rainy":
                    console.log("Take your umbrella!");
                    break;
                  default:
                    console.log("How"s the weather outside?");
                    break;
                }</code>
            </pre>
          </section>
        </article>
        <article id="functions">
          <h1>함수</h1>
          <p>함수는 스크립트 안에서 특별한 역할을 수행하는 명령문을 한데 모은 블록문이며, 데이터 타입은 객체 타입의 함수 타입입니다. 함수는 키워드 function 으로 선언한 뒤 함수명 식별자(identifier), 함수 안에서 쓰일 매개변수(parameter), 함수 안의 명령문(statements)으로 구성됩니다. 함수는 블록문 이후 함수를 호출해야 실행됩니다.</p>
          <p>함수는 기본값으로 undefined를 갖고있지만, 특정한 값을 반환하고 싶다면 return문이 함수 블록문 안에 있어야 합니다.</p>
          <pre>
            <code>
                function funcA() {
                  console.log("Function A is working!");
                }
                funcA(); // "Function A is working!"
                /*
                function 기본문
                */

                function getArea(width, height) {
                  console.log(width * height);
                }
                getArea(60, 20); // 1200
                /*
                function 기본문 + param
                */

                function timeFlies(year){
                  yearAgo = year - 1; 
                  return yearAgo;
                }
                timeFlies(); // if (year = 2019) {yearAgo = 2018}
                /*
                function 기본문 + param + return
                */</code>
          </pre>
          <section id="functionDefinition">
            <h2>함수 정의 Function Definition</h2>
            <p>아래의 예제들은 함수를 더욱 간단하게 쓸 수 있도록 ECMAScript 6 이후 등장한 함수 정의 방법들입니다. 그러나 브라우저간 호환성 문제가 있기 때문에 로컬 작업에만 사용할 것을 권장합니다.</p>
            <div class="ex" id="functionExpr">
              <h3>함수표현식 Function Expressions</h3>
              <p>함수표현식의 문법은 함수 기본문과 거의 같습니다. 앞에 선언 키워드로 식별자를 선언한 뒤, function 키워드를 param 앞에 붙입니다.</p>
              <pre>
                <code>
                var getArea = function(width, height) {
                  var area = width * height;
                  return area;
                }</code>
              </pre>
            </div>
            <div class="ex" id="functionArrow">
              <h3>화살표 함수식 Arrow Function Notation</h3>
              <p>함수표현식에서 function 키워드가 arrow로 바뀌고, arrow는 param 뒤에 붙습니다.</p>
              <pre>
                <code>
                var getArea = (width, height) => {
                  var area = width * height;
                  return area;
                }</code>
              </pre>
            </div>
            <div class="ex" id="functionConciseArrow">
              <h3>축약 화살표 함수식 Concise Arrow Notation</h3>
              <p>더욱 축약된 함수식은 함수 안에 따로 return값을 선언하지 않고도 함수값을 출력합니다.</p>
              <pre>
                <code>
                var getArea = (width, height) => {
                  var area = width * height;
                  return area;
                }
                /*
                이 함수식은 아래와 같습니다.
                */

                var getArea = (width, height) => width * height;</code>
              </pre>
            </div>
          </section>
        </article>
        <article id="scope">
          <h1>스코프</h1>
          <p>스크립트 내의 모든 변수는 식별자가 어디에서 선언되었는지에 따라, 다른 코드가 해당 변수에 접근할 수 있는 일정한 범위를 가집니다. 이러한 규칙을 스코프(유효범위, scope)라 부릅니다. JavaScript에서 스코프는 스크립트 내 어느 위치에서든 변수에 접근할 수 있는 전역 스코프(global scope)와 블록문(block statement) 중에서 함수 안에서만 접근할 수 있는 지역 스코프(local scope)로 나뉩니다. 변수는 선언된 위치에 따라 스코프를 가지고, 스코프에 따라 전역 변수(global variable)와 지역 변수(local variable)로 나뉩니다.</p>
          <pre>
            <code>
                var globalScope = "global scope"

                function scopeA(paramA) {
                  var localScope_A = "local scope A"

                  function scopeB(paramB) {
                    var localScope_B = "local scope B"

                    function scopeC(paramC) {
                      var localScope_C = "local scope C"
                    }
                  }
                }
                /*
                전역 변수는 함수 바깥에 전역 스코프를, 
                지역 변수와 각 함수의 parameter는
                각 함수 안에 지역 스코프를 지닙니다.
                */</code>
          </pre>
          <section id="globalScope">
            <h2>전역 스코프 Global Scope</h2>
            <p>스크립트 안, 함수 바깥에서 선언된 변수는 어디서든지 참조할 수 있는 전역 스코프를 지니고 전역 변수가 됩니다. var 키워드로 선언한 전역 변수는 전역 객체(global object) window의 프로퍼티가 됩니다.
            </p>
            <div class="ex" id="scopePollution">
              <h3>스코프 공해 Scope Pollution</h3>
              <p>JavaScript는 변수의 선언을 시작하는 특별한 위치가 없고 스크립트 내 어느 곳에서나 변수 선언을 시작할 수 있습니다. 그리고 변수의 이름이 중복될 수 있기 때문에, 전역 변수를 자주 사용하기 쉽습니다. 그런데 전역 변수를 자주 사용하면 의도치않게 변수가 재할당되어 변수값을 예측하기 어려워지는 경우가 많습니다. 이 현상을 스코프 공해(scope pollution)이라 부릅니다. 따라서 변수를 선언할 때 전역 변수는 최대한 사용을 자제하는 것이 좋습니다.</p>
              <pre>
                <code>
                  var designer = "NaYeong"
                  function scopeDesigner() {
                    var designer = "Ujin";
                    console.log(designer);
                    var designer = "HyoMin";
                    console.log(designer);
                  }
                  console.log(designer); // "NaYeong"
                  scopeDesigner(); // "Ujin" "HyoMin"
                  /*
                  전역 변수를 많이 사용하면 의도한 값과 
                  다른 결과값이 출력될 수 있습니다.
                  */</code>
              </pre>
            </div>
          </section>
          <section id="localScope">
            <h2>지역 스코프 Local Scope</h2>
            <p>JavaScript에서 스코프는 블록문 단위(block-level)가 아닌 함수 단위(function-level)로 설정됩니다. 함수 안에 조건문(for), 반복문(if), 또는 다른 함수가 포함되어있어도 같은 함수 안에 있는 모든 변수는 같은 지역 스코프를 가집니다. 이때 함수 안에 선언된 변수를 지역 변수(local scope)라고 부릅니다. 함수 안에서 선언된 변수는 함수값이 return되어 함수 밖으로 나오지 않으면 함수 밖에서 참조할 수 없습니다.</p>
            <pre>
              <code>
                function localScope() {
                  if (true) {
                    var a = 0;
                    for (var a = 1; a < 5; a++) {
                      console.log("a는 " + a + " (for문)"); 
                    }
                    console.log("a는 " + a + " (if문)"); 
                  }
                  console.log("a는 " + a + " (함수)"); 
                }
                localScope();   
                //a는 1, 2, 3, 4 (for문)   
                //a는 5 (if문)          
                //a는 5 (함수 localScope)
                /*
                함수 안에 다른 블록문이 들어있어도
                블록문과 함수 안에 선언된 변수는 모두 지역 변수입니다.
                같은 스코프를 가진 변수이므로 서로 참조할 수 있습니다.
                */</code>
            </pre>
            <div class="question">
              <span>Q1.</span><h4>코드 예제에서 <a href="#">반복문</a> 조건이 `a < 5`인데<br>왜 반복문 밖의 콘솔은 'a는 5'라고 나오나요?</h4>
              <span>A1.</span><p>for문에서 1~4까지 결과값이 나왔고, for문의 마지막 계산 (a = 4, a++)에서 결과값은 a = 5 입니다.<br>a = 5이므로 더이상 for문의 콘솔은 실행되지 않지만, 아래 if문에서는 가장 마지막으로 선언된 a = 5 값을 참조하는 것입니다.<br>함수 또한 if문에서 참조한 a = 5 값을 그대로 참조한 것입니다.</p>
            </div>
            <div class="ex" id="functionScope">
              <h3>함수레벨 스코프 Function-Level Scope</h3>
              <p>JavaScript에서, 함수 안에서 선언된 매개변수와 변수는 함수 밖에서는 유효하지 않습니다. 전역 스코프에서는 전역 변수만 참조할 수 있고 함수 내 지역 스코프에서는 지역 변수와 전역 변수를 모두 참조할 수 있습니다. 만약 전역변수와 지역변수가 같은 식별자로 중복 선언되었다면, 함수는 지역 변수를 우선 참조하여 결과값을 냅니다.</p>
              <pre>
                <code>
                var ceo = "Seon-Jung";
                function scopeFunc() {
                  var ceo = "Ari";
                  console.log(ceo); 
                }
                scopeFunc(); // "Ari"
                console.log(ceo); // "Seon-Jung"
                /*
                전역 변수와 지역 변수가 같은 식별자로 중복 선언되었다면
                함수는 지역 변수를 우선 참조합니다.
                */

                var ceo = "Seon-Jung";
                function scopeFunc() {
                  ceo = "Ari";
                  console.log(ceo);
                }
                scopeFunc(); // "Ari"
                console.log(ceo); // "Ari"
                /*
                함수 내에서는 전역 변수의 값을 참조하고 변경할 수 있습니다.
                */</code>
              </pre>
            </div>
            <div class="ex" id="nestedFuncScope">
              <h3>내부함수의 스코프 Nested Function Scope</h3>
              <p>함수 안에 있는 다른 함수, 즉 내부 함수는 자신을 포함하고 있는 외부 함수의 변수에 접근할 수 있습니다.</p>
              <pre>
                <code>
                var ceo = "Seon-Jung";
                function scopeFunc2() {
                  var ceo = "Ari";
                  console.log(ceo);

                  function scopeFunc3() {
                    console.log(ceo);
                  }
                  scopeFunc3();
                }
                scopeFunc2(); // "Ari" "Ari"
                console.log(ceo); // "Seon-Jung"
                /*
                함수 안에 있는 함수는 
                외부 함수의 변수에 접근할 수 있습니다.
                */

                var ceo = "Seon-Jung";
                function scopeFunc2() {
                  var ceo = "Ari";
                  console.log(ceo);

                  function scopeFunc3() {
                    ceo = "HaYun";
                    console.log(ceo);
                  }
                  scopeFunc3();
                }
                scopeFunc2(); // "Ari" "HaYun"
                console.log(ceo); // "Seon-Jung"
                /*
                함수 안에 있는 함수는 
                외부 함수의 변수를 참조하고 변경할 수 있습니다.
                */</code>
              </pre>
            </div>
            <div class="ex" id="nonBlockScope">
              <h3>비 블록레벨 스코프 Non Block-Level Scope</h3>
              <p>블록문 안에 있지만 함수 안에 있지 않다면 JavaScript 에서는 전역 변수로 처리됩니다.</p>
              <pre>
                <code>
                var programmer = "HanSun"
                if(true) {
                  var programmer = "Yura";
                  console.log(programmer); // "Yura"
                }
                console.log(programmer); // "Yura"
                /*
                함수가 아닌 블록문 안에 선언된 변수는
                전역 변수입니다.
                */</code>
              </pre>
            </div>
            <div class="ex" id="blockScope">
              <h3>블록레벨 스코프 Block-Level Scope</h3>
              <p>ECMAScript 6에서 등장한 let 키워드로 변수를 선언하면 함수 단위 스코프가 아닌 블록문 단위 스코프로 설정할 수 있습니다. 이 경우, 함수 내 블록문에 선언된 변수들은 블록문마다 스코프를 가지고, 해당 블록문을 벗어나면 더 이상 참조되지 않습니다.</p>
              <pre>
                <code>
                function scopeBlock() {
                  if (true) {
                    let b = 0;
                    for (let b = 1; b < 5; b++) {
                      console.log("b는 " + b + " (for문)"); //b는 1, 2, 3, 4 (for문)
                    }
                    console.log("b는 " + b + " (if문)"); //b는 0 (if문)
                  }
                  console.log("b는 " + b + " (함수)"); //ReferenceError: b is not defined
                }
                scopeBLock();
                /*
                let 키워드로 변수를 선언하면 
                블록문마다 서로 다른 지역 스코프를 가집니다.
                이 경우 블록문 안에 선언된 변수는
                지역 변수가 됩니다.
                */</code>
              </pre>
            </div>
          </section>
      <!--<article id="arrays">
        <section id="">
        </section>
      </article>-->
      <!--<article id="executionContext">
        <section id="">
        </section>
      </article>-->
      </main>
      <footer>
        <div class="footer-contents">
          <p>Referenced by Codecademy, MDN, and StackOverflow<br>
          Written & Edited by Lee Ujin</p>
        </div>
      </footer>
    </div>
  </body>
</html>