<!DOCTYPE html>
<html lang="ko">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Intro | JavaScript</title>
    <!--common css-->
    <link rel="stylesheet" href="styles/common-compressed.css">
  </head>
  <body>
    <header>
      <nav>
        <ul>
          <li><a id="home" href="https://ujin-lee.github.io/Designer-Learns-Code/JavaScript1.html">HOME</a></li>
        </ul>
      </nav>
    </header>
    <div class="sidebar">
      <ul>
        <li class="menu-top"><a href="#intro">JavaScript 소개</a></li>
        <li class="menu-dropdown"><a href="#specification">표준 명세</a></li>
        <li class="menu-top"><a href="#tutorial">튜토리얼</a></li>
        <li class="menu-dropdown"><a href="#comments">주석</a></li>
        <li class="menu-dropdown"><a href="#console">콘솔</a></li>
        <li class="menu-top"><a href="#variable">변수</a></li>
        <li class="menu-dropdown"><a href="#variableDeclaring">변수 선언</a></li>
        <li class="menu-dropdown"><a href="#variableScope">변수 범위</a></li>
        <li class="menu-dropdown"><a href="#variableAssignment">변수 할당</a></li>
        <li class="menu-dropdown"><a href="#variableHoisting">변수 호이스팅</a></li>
        <li class="menu-top"><a href="#dataTypes">데이터 타입</a></li>
        <li class="menu-dropdown"><a href="#number">숫자</a></li>
        <li class="menu-dropdown"><a href="#string">문자열</a></li>
        <li class="menu-dropdown"><a href="#boolean">부울</a></li>
        <li class="menu-dropdown"><a href="#nullUndefined">빈값</a></li>
        <li class="menu-top"><a href="#operators">연산자</a></li>
        <li class="menu-dropdown"><a href="#arithmeticOp">산술연산자</a></li>
        <li class="menu-dropdown"><a href="#assignmentOp">할당연산자</a></li>
        <li class="menu-dropdown"><a href="#comparisonOp">비교연산자</a></li>
        <li class="menu-dropdown"><a href="#logicalOp">논리연산자</a></li>
        <li class="menu-top"><a href="#object">객체</a></li>
        <li class="menu-dropdown"><a href="#property">프로퍼티</a></li>
        <li class="menu-dropdown"><a href="#methods">메소드</a></li>
        <!--<li class="menu-dropdown"><a href="#built-inObj">내장객체</a></li>-->
        <li class="menu-top"><a href="#conditionalStm">조건문</a></li>
        <li class="menu-dropdown"><a href="#ifElse">if & else</a></li>
        <li class="menu-dropdown"><a href="#switch">switch</a></li>
        <li class="menu-top"><a href="#functions">함수</a></li>
        <li class="menu-dropdown"><a href="#functionDefinition">함수 정의</a></li>
        <!--<li class="menu-top"><a href="#arrays">배열</a></li>-->
      </ul>
    </div>
    <div class="main-wrapper">
      <main class="main-content">
        <article id="intro">
          <h1>JavaScript 소개</h1>
          <p>JavaScript(JavaScript)는 1995년 Netscape Navigator라는 웹 브라우저에 탑재되어 <a href="https://developer.mozilla.org/ko/docs/Web/JavaScript/%EC%96%B8%EC%96%B4_%EB%A6%AC%EC%86%8C%EC%8A%A4">ECMAScript(ES)</a> 라는 이름으로 처음 공개되었습니다. JavaScript는 다른 프로그래밍 언어에 비해 적은 양의 기능을 포함하고 있지만, 웹 브라우저, 웹 서버, 게임 엔진, <a href="https://helpx.adobe.com/kr/photoshop/using/scripting.html" target="_blank">어도비 프로그램</a> 등 다양한 구동 환경과 조합하여 유용한 기능들과 응용 프로그램을 만들 수 있습니다.</p>
          <ul>
            <li><a href="https://developer.mozilla.org/ko/docs/A_re-introduction_to_JavaScript">JavaScript 입문하기 | MDN</a></li>
            <li><a href="https://developer.mozilla.org/ko/docs/Learn/JavaScript/First_steps/What_is_JavaScript">웹 개발에서의 JavaScript 입문하기 | MDN</a></li>
          </ul>
          <section id="specification">
            <h2>표준 명세 Standard Specification</h2>
            <p>표준 명세(Standard Specification)는 프로그래밍 언어의 문법 및 기능을 상세하게 정의한 일종의 프로그래밍 언어 사전입니다. JavaScript의 표준 명세인 <a href="https://developer.mozilla.org/ko/docs/Web/JavaScript/%EC%96%B8%EC%96%B4_%EB%A6%AC%EC%86%8C%EC%8A%A4">ECMAScript(ES)</a>는 1997년에 처음 제정되었고, 2015년에 제정된 <a href="https://jsdev.kr/t/es6/2944">ES2015(ES6)</a>이후 표준 명세가 빠르게 업데이트 되고있습니다. 초기의 자바스크는 웹 브라우저 간 표준문법 및 기능이 매우 달라 브라우저 간 호환성이 낮았기 때문에 잘 사용되지 않았습니다. 그러나 1999년 ES3, 2009년 ES5가 나오면서 차츰 호환성 문제가 해결되고, 새로운 문법과 기능들이 추가되면서 JavaScript의 활용도가 이전보다 훨씬 높아지면서 재조명되기 시작했습니다.
            </p>
            <ul>
              <li><a href="http://kangax.github.io/compat-table/es2016plus/" target="_blank">브라우저별 JavaScript 지원 기능 확인하기</a></li>
              <li><a href="https://tc39.github.io/ecma262/" target="_blank">JavaScript의 최신 표준 명세 보러가기</a></li>
            </ul>
          </section>
        </article>
        <article id="tutorial">
          <h1>튜토리얼</h1>
          <p>JavaScript의 문법은 대부분 Java, C, C++로부터 빌려왔습니다. JavaScript에서는 대소문자를 구분하고, Unicode 문자셋을 이용하므로 영어 외의 다양한 언어를 작성할 수 있습니다. JavaScript의 명령은 명령문(Statement)으로 부르고, 세미콜론(;)으로 분리합니다. 스페이스(space-bar), 탭(tab), 줄바꿈 문자는 공백으로 간주됩니다.</p>
          <p><a href="https://developer.mozilla.org/ko/docs/Web/JavaScript/Guide/Values,_variables,_and_literals#%EA%B8%B0%EB%B3%B8">JavaScript 기본 문법 보기 | MDN</a></p>
          <section id="comments">
            <h2>주석 Comments</h2>
            <p>주석은 공백으로 취급되고 스크립트 실행에서 제외됩니다.</p>
            <pre>
              <code>
                // 이 주석은 한 줄을 작동에서 제외시킵니다.

                /*
                이 주석은 여러 줄을 작동에서 제외시킵니다.
                이렇게요.
                */

                하나의 문장에서 /*이 부분만*/ 작동에서 제외시키고 싶을 때에도 쓸 수 있습니다.</code>
            </pre>
            <p>JavaScript에서 주석 처리된 코드는 실제로 작동하지 않지만 사람들은 브라우저 검사기(Inspector)나 코드 공유를 할 때 주석을 읽을 수 있습니다. 특히 접근이 쉬운 HTML 파일 안에 script 태그로 JavaScript를 작성한다면 브라우저 검사기를 통해 일반 유저도 쉽게 주석을 볼 수 있습니다.</p>
          </section>
          <section id="console">
            <h2>콘솔 Console</h2>
            <div class="ex">
              <h3>콘솔에 출력하기 console.log()</h3>
              <p>console.log();는 코드의 데이터와 액션을 모두 포함해 정의하는 데이터를 <a href="https://developers.google.com/web/tools/chrome-devtools/console/" target="_blank">브라우저의 Console 창</a>에 출력해서 보여줍니다.</p>
              <pre>
                <code>
                console.log("Hello World"); // "Hello World"
                /* 콘솔에 데이터 출력하기 */

                const name = "Ujin";
                const age = 26;
                const city = "Seoul";
                console.log(name, "/", age, "/", city);

                // "Ujin/26/Seoul"
                /* 콘솔에 여러 데이터를 한 번에 출력하기 */</code>
              </pre>
            </div>
          </section>
        </article>
        <article id="variable">
          <h1>변수</h1>
          <p>어떠한 값에 상징적인 이름을 붙일 때 <a href="#variableDeclaring">변수(Variable)를 선언합니다.</a> 변수를 선언할 때는 정의 키워드(var, let, const), 변수명, 비교연산자 = (assignment operator), 값(value)을 지정합니다. 변수 선언이 완료되었다면 이후 변수는 해당하는 값을 대신 내보냅니다.</p>
          <pre>
            <code>
              var myName = "Ujin";
              console.log(myName); // "Ujin"

              /*
              var, let, const : 정의 키워드
              myName : 변수명
              = : 비교연산자
              "Ujin" : 값
              */</code>
          </pre>
          <p>변수명(identifier)을 지을 때 알아두어야 할 몇 가지 규칙이 있습니다.</p>
          <ol>
            <li>변수명의 첫글자는 문자, 밑줄(_), 달러 기호($)로 시작해야합니다. 첫글자를 숫자로는 시작할 수 없습니다.</li>
            <li>변수명 안의 대문자와 소문자를 분명히 구분해야 합니다. 같은 변수명에 소문자와 대문자를 다르게 적으면 다른 변수명으로 인식됩니다.</li>
            <li>변수명의 첫 단어 이후 다음 단어들은 <a href="http://guswnsxodlf.github.io/camelcase-pascalcase-snakecase" target="_blank">첫 글자를 대문자로 적어줍니다. (camel casing)</a></li>
            <li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Lexical_grammar#Keywords" target="_blank">키워드</a>는 변수명으로 쓸 수 없습니다. 키워드는 표준명세에서 약속된 예약어(Resered Words)로, 변수 뿐만아니라 함수(function), 메소드(method), 객체 식별자(object identifier)의 이름으로 가져올 수 없습니다.</li>
          </ol>
          <section id="variableDeclaring">
            <h2>변수 선언 Variable Declaring</h2>
            <p>기존에는 변수를 선언하기 위해 var 키워드를 사용했지만, var로 변수를 정의한 경우 변수값이 중간에 초기화 되는 등 <a href="https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Strict_mode">엄격한 실행모드(strict mode)</a>에서 의도치않은 결과를 출력할 수 있습니다. 따라서 <a href="https://jsdev.kr/t/es6/2944">ES6</a> 이후로 새로 등장한 let, const 키워드를 쓰는 것이 권장됩니다.</p>
            <div class="ex" id="variableKeywords">
              <h3>var</h3>
              <p>var로 변수를 정의하면 첫 변수값을 지정한 이후에도 (또는 변수값을 아직 지정하지 않은 경우에도) 기존의 값을 초기화하고 새 값을 지정할 수 있습니다.</p>
              <pre>
                <code>
                var designer = "Ujin";
                console.log(designer); // "Ujin"
                var designer = "Jiyoung";
                console.log(designer); // "Jiyoung"

                var designer;
                console.log(designer); // undefined
                var designer = "Jiyoung"
                console.log(designer); // "Jiyoung"</code>
              </pre>
              <h3>let</h3>
              <p>let도 변수를 정의하면 첫 변수값을 지정한 이후에도 (또는 변수값을 아직 지정하지 않은 경우에도) 기존의 값을 초기화하고 새 값을 지정할 수 있습니다. 그러나 let은 변수값을 다시 지정할 때 var과 달리 변수 앞에 let 키워드를 쓰지 않습니다.</p>
              <pre>
                <code>
                let designer = "Ujin";
                console.log(designer); // "Ujin"
                designer = "Jiyoung";
                console.log(designer); // "Jiyoung"

                let designer;
                console.log(designer); // undefined
                designer = "Jiyoung"
                console.log(designer); // "Jiyoung"

                let designer = "Ujin";
                console.log(designer);
                let designer = "Jiyoung";
                console.log(designer);
                // SyntaxError: Identifier "designer" has already been declared</code>
              </pre>
              <h3>const</h3>
              <p>const로 변수를 정의하면 첫 변수값을 지정한 이후에 새 값을 지정할 수 없고, 변수의 초기값을 반드시 적어야 합니다. 변수값을 중간에 초기화하는 경우가 아니라면 일반적으로 정의 키워드를 const로 사용합니다.</p>
              <pre>
                <code>
                const designer = "Ujin";
                console.log(designer); // "Ujin"
                designer = "Jiyoung"; // TypeError: Assingment to constant variable.

                const designer; // SyntaxError: Missing initializer in const declaration</code>
              </pre>
            </div>
          <section id="variableScope">
            <h2>변수 범위 Variable Scope</h2>
            <p>변수 범위 개념은 <a href="https://jsdev.kr/t/es6/2944">ES6</a> 이후 등장했습니다. 함수의 바깥에서 선언된 변수는 문서 전체에 해당 변수가 작동합니다. 이러한 변수를 전역 변수(global-scope)라고 합니다. 그렇지만 함수 안에서 변수를 선언했다면 그 함수 안에서만 작동합니다. 이러한 변수를 지역 변수(block-scope)라고 합니다. 일반적으로 전역 변수를 정의할 때는 함수 바깥에서 미리 정의하고, 함수 안에서만 작동할 변수는 지역 변수로 정의합니다.</p>
            <pre>
              <code>
              if (true) {
                var designer = "Ujin";
                console.log(designer); // "Ujin"
              }
              console.log(designer); // "Ujin"
              /*
              var은 전역 변수이므로 블록 밖에서도 동작합니다.
              */

              if (true) {
                let programmer = "Jiyeong";
                console.log(programmer); // ""Jiyeong"
              }
              console.log(programmer); // ReferenceError: programmer is not defined
              /*
              let은 블록 변수이므로 블록 안에서만 동작합니다.
              */</code>
            </pre>
            <p>지역변수값을 다른 함수에서 불러오려고 하면 ReferenceError가 나옵니다.</p>
            <pre>
              <code>
              function getX() {
                var x = "x"; 
                getY();
              }
              /* 
              function getX()의 지역변수 x는
              다른 함수로 내보낼 수 없습니다. 
              */

              function getY() {
                return x; // ReferenceError: x is not defined
              }
              /* 
              function getX()의 지역변수이므로 
              다른 함수에서 return할 수 없습니다. 
              */

              getX();</code>
            </pre>
          </section>
          <section id="variableAssignment">
            <h2>변수 할당 Variable Assignment</h2>
            <p>var, let 정의 키워드를 앞에 둔 변수에 초기값을 지정하지 않았다면 그 변수는 <a href="#nullUndefined">undefined</a> 값을 할당받습니다. 이 경우 변수 선언이 아닌 변수 할당이라고 합니다. 단, 정의 키워드로 선언된 적 없는 변수에 접근하면 ReferenceError가 발생합니다. <a href="#variableHoisting">var과 let, const는 변수가 선언된 위치에 따라 다른 결과를 출력합니다.</a></p>
            <pre>
              <code>
              var a;
              console.log("a는 " + a); 
              // "a는 undefined"

              console.log("b는 " + b); 
              var b;
              // "b는 undefined"

              console.log("c는 " + c); 
              // ReferenceError: c is not defiend


              let x;
              console.log("x는 " + x); 
              // "x는 undefined"

              console.log("y는 " + y); 
              let y;
              // ReferenceError: Cannot access "y" before initialization</code>
            </pre>
          </section>
          <section id="variableHoisting">
            <h2>변수 호이스팅 Variable Hoisting</h2>
            <p>변수 호이스팅 개념은 <a href="https://jsdev.kr/t/es6/2944">ES6</a> 이후 등장했습니다. 호이스팅은 '끌어올리기'로 직역할 수 있습니다. 즉, 함수가 작동할 때 함수 내에서 선언된 변수는 선언된 위치에 상관없이 일단 함수 내의 맨 위로 끌어올려지는 것을 뜻합니다. 끌어올려진 변수는 임의의 값으로 undefined를 할당받습니다. 이후 함수가 실행되면서 undefined값을 할당받은 변수가 사용됩니다. 단, 끌어올려진 변수는 사용되거나 다시 선언되거나, 값을 초기화해도 여전히 undefined를 반환합니다.</p>
            <p>호이스팅 규칙에 따라 함수 내의 모든 var 변수는 가능한 함수 위 쪽에 작성하는 것이 좋습니다.</p>
            <pre>
              <code>
              var a = "A";

              function getA() {
                console.log("a는 " + a); // "a는 undefined"
                var a = "a";
                console.log("a는 " + a); // "a는 a"
              }
              getA();
              
              /*
              위 함수는 아래와 같은 과정으로 실행됩니다.
              */

              var a = "A";

              function getA() {
                var a; // undefined
                console.log("a는 " + a); // "a는 undefined"
                var a = "a";
                console.log("a는 " + a); // "a는 a"
              }
              getA();</code>
            </pre>
            <p>하지만 let, const는 호이스팅을 지원하지 않습니다. let, const로 변수가 선언되기 전에 블록 안에서 변수를 참조하면 ReferenceError가 나타납니다. 이 때 변수는 블록이 시작할 때부터 선언될 때까지 작동하지 않습니다.</p>
            <pre>
              <code>
              let a = "A";

              function getA() {
                console.log("a는 " + a); 
                // ReferenceError: Cannot access "A" before initialization
                let a = "a";
                console.log("a는 " + a);
              }
              getA();</code>
            </pre>
          </section>
        </article>
        <article id="dataTypes">
          <h1>데이터 타입</h1>
          <p>JavaScript에서 다루는 값은 모두 데이터 타입(Data Types)을 가지고 있습니다. <a href="https://developer.mozilla.org/ko/docs/Web/JavaScript/Guide/Values,_variables,_and_literals#%EB%8D%B0%EC%9D%B4%ED%84%B0_%EA%B5%AC%EC%A1%B0_%EB%B0%8F_%ED%98%95">JavaScript의 데이터 타입</a>은 기본적으로 7개로 분류합니다. 이 중에서 함수, 배열, 날짜, 정규식은 특별한 종류의 객체 타입으로 볼 수 있습니다.</p>
          <ol>
            <li><a href="#number">숫자 number</a></li>
            <li><a href="#string">문자열 string</a></li>
            <li><a href="#boolean">부울 boolean</a></li>
            <li><a href="#nullUndefined">널 null</a></li>
            <li><a href="#nullUndefined">미정의 undefined</a></li>
            <li><a href="#object">객체 object</a></li>
            <div>
              <ol class="inner-ol">
                <li><a href="#functions">함수 function</a></li>
                <li>배열 array</li>
                <li>날짜 date</li>
                <li>정규식 regExp</li>
              </ol>
            </div>
            <li>심볼 symbol</li>
          </ol>
          <div class="ex" id="typeOf">
            <h3>typeof</h3>
            <p>연산자 typeof는 피연산자의 데이터 타입을 문자열 형태로 반환합니다.</p>
            <pre>
              <code>
                typeof 1; // number
                typeof "hello"; // string
                typeof true; // boolean
                typeof null; // object
                typeof undefined; // undefined</code>
            </pre>
          </div>
          <section id="number">
            <h2>숫자 Number</h2>
            <p>숫자는 정수, 실수, 0, -0을 포함한 수입니다. 문자열의 형태를 지녔지만 숫자의 개념을 다루는 NaN(Not a Number), Infinity, -Infinity도 숫자 타입입니다.</p>
            <pre>
              <code>
                1, 23.42, -7, 0, -0, NaN, Infinity, -Infinity</code>
            </pre>
            <p>숫자 타입끼리의 계산에는 <a href="#arithmeticOp">산술연산자</a>가 사용됩니다. JavaScript에서 숫자와 문자열 값 사이에 산술연산자 <a href="#addArith">+(add)</a>를 사용해 식을 내면 그 값은 숫자로 반환됩니다. 그 외의 다른 연산자를 포함한 식은 반드시 문자열로 반환하지는 않습니다.</p>
            <pre>
              <code>
                "Answer: " + 38 // "Answer: 38"
                2019 + "번 고객" // "2019번 고객"

                "12" - 3 // 9
                "12" + 3 // 123</code>
            </pre>
            <div class="ex" id="convertToNum">
              <h3>Number(), parseFloat(), parseInt()</h3>
              <p>Number(), parseFloat(), parseInt()는 데이터의 첫글자부터 데이터를 숫자 타입으로 변환합니다.<br>데이터의 첫글자가 숫자로 나타낼 수 없는 문자열(알파벳, 공백 등)이라면 NaN을 출력합니다.</p>
              <pre>
                <code>
                const a = "10"; // 정수
                const b = "2.019"; // 소수점이 있는 실수
                const c = "3a"; // 정수 + 알파벳
                const d = "3.4 5.6 7.8" // 소수점이 있는 실수 + 공백
                const e = "40 sec" // 정수 + 공백 + 알파벳
                const f = "Hi 2019" // 알파벳 + 공백 + 정수

                Number(a); // 10
                Number(b); // 2.019
                Number(c); // NaN
                Number(d); // NaN
                Number(e); // NaN
                Number(f); // NaN

                /* 
                Number()는 
                숫자로 나타낼 수 없는 문자열이 포함되어있으면 
                NaN을 출력합니다.
                */

                parseFloat(a); // 10
                parseFloat(b); // 2.019
                parseFloat(c); // 3
                parseFloat(d); // 3.4
                parseFloat(e); // 40
                parseFloat(f); // NaN

                /* 
                parseFlaot()는 
                숫자로 나타낼 수 없는 문자열이 포함되어있으면 
                그러한 문자열을 제외한 뒤 앞글자부터 출력합니다. 
                그러한 문자열이 첫글자일 경우 NaN을 출력합니다.
                */

                parseInt(a); // 10
                parseInt(b); // 2
                parseInt(c); // 3
                parseInt(d); // 3
                parseInt(e); // 40
                parseInt(f); // NaN

                /* 
                parseInt()는 
                숫자로 나타낼 수 없는 문자열이 포함되어있으면 
                그러한 문자열을 제외한 뒤 앞글자부터 소수점을 지우고 정수(Integer)로만 출력합니다. 
                그러한 문자열이 첫글자일 경우 NaN을 출력합니다.
                */</code>
              </pre>
            </div>
            <div class="ex" id="math">
              <h3>Math()</h3>
              <p>Math()는 수학적인 상수와 함수를 간단한 식으로 나타내거나 변환할 수 있는 <!--<a href="#built-inObj">-->내장객체<!--</a>-->입니다.</p>
              <pre>
                <code>
                Math.E(); // 자연상수 e (2.71...)
                Math.PI(); // 원주율 (3.14...)

                Math.sin(); // 사인
                Math.cos(); // 코사인
                Math.tan(); // 탄젠트
                Math.log(); // 밑을 자연상수로 두는 로그함수
                Math.exp(); // 밑을 자연상수로 두는 지수함수
                Math.sqrt(); // 제곱근
                
                Math.abs(); // 절댓값
                Math.ceil(); // 소수점 이하 올림
                Math.floor(); // 소수점 이하 내림
                Math.round(); // 소수점 이하 반올림
                Math.trunc(); // 소수점 이하 잘라내기

                Math.max(); // 최댓값
                Math.min(); // 최소값

                Math.random(); // 랜덤값</code>
              </pre>
            </div>
          </section>
          <section id="string">
            <h2>문자열 String</h2>
            <p>문자열은 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Text_formatting" target="_blank">"..."(Single Quotes) 또는 "..."(Double Quotes)</a> 안에 둘러싸인 모든 글자, 숫자, 공백, 심볼 등을 포함합니다. Console.log로 문자열을 출력하면 "..."로 출력됩니다.</p>
            <pre>
              <code>
                "This is String!", "문자열은", "이러한 형태입니다."</code>
            </pre>
            <div class="ex" id="templateLiterals">
              <h3><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals" target="_blank">템플릿 문자열 Template Literals</a></h3>
              <p><a href="https://jsdev.kr/t/es6/2944">ES6</a> 이후 등장한 템플릿 문자열로 문자열을 간단하게 반환하고 채워넣을 수 있습니다. 템플릿 문자열은 "",""이 아닌 ``(backticks, 키보드의 1!키 왼쪽에 있는 키)로 둘러싸입니다. 반환될 문자열 변수를 ${} 안에 넣으면 해당되는 변수값이 출력됩니다.</p>
              <pre>
                <code>
                const name = "Jiyeong";
                const age = 37;
                const city = "Busan";
                console.log(`Hi, My name is ${name}. 
                I"m ${age} now. 
                And I"m from ${city}.`);

                /*
                "Hi, My name is Jiyeong. 
                I"m now 37. 
                And I"m from Busan."
                */</code>
              </pre>
            </div>
            <div class="ex" id="stringWorks">
              <h3>.length</h3>
              <p>문자열의 길이(개수)값, 또는 배열의 요소 개수를 반환합니다.</p>
              <pre>
                <code>
                const weather = "2019.04.14 Today: 날씨 맑음!!"
                weather.length; // 25</code>
              </pre>
              <h3>charAt(n), indexOf(), substring(n1, n2)</h3>
              <p>각각 n번째 문자열, 특정 문자열의 순서(n번째), n1번째부터 n2번째까지의 문자열을 반환합니다.</p>
              <pre>
                <code>
                const weather = "2019.04.14 Today: 날씨 맑음!!"

                weather.charAt(6); // 4
                weather[6]; // 4
                weather.indexOf("날"); // 18
                weather.substring(0, 4); // 2019</code>
              </pre> 
              <h3>toUpperCase(), startsWith()</h3>
              <p>각각 문자열을 대문자로 반환하고, 전체 문자열이 해당 문자열로 시작하는지 알려주는 진리값을 반환합니다.</p>
              <pre>
                <code>
                const weather = "2019.04.14 Today: 날씨 맑음!!"

                weather.toUpperCase(); // "2019.04.14 TODAY: 날씨 맑음!!"
                weather.startsWith("2019.04"); // true</code>
              </pre>  
            </div>
            <div class="ex" id="convertToStr">
              <h3>String()</h3>
              <p>변수의 타입을 문자열로 변환합니다. null, undefined값도 변환할 수 있습니다.</p>
              <pre>
                <code>
                const x = 1;
                const y = 2;
                let z;

                x + y; // 3
                String(x) + String(y); // "12"
                String(z); // "undefined"</code>
              </pre>
            </div>
          </section>
          <section id="boolean">
            <h2>부울 Boolean</h2>
            <p>부울은 데이터에 대한 조건이 참 또는 거짓(true or false, yes or no)을 나타냅니다. 이 조건을 부울값 또는 진리값이라 부릅니다. 주로 서로 다른 데이터값의 일치 여부를 확인하기 위해 다양한 <a href="#operators">연산자</a>와 함께 사용합니다.</p>
            <pre>
              <code>
                1 === 1 // true
                1 === 2 // false</code>
            </pre>
            <div class="ex" id="truthyFalsy">
              <h3>부울이 아닌 데이터 타입의 진리값 Truthy & Falsy</h3>
              <p>데이터 타입이 정확히 부울은 아니지만 거짓으로 판정되는 값을 falsy값이라 부르고, 나머지 값을 truthy값이라 부릅니다. JavaScript는 아래의 데이터 타입을 falsy 값으로 판단합니다.</p>
              <ol>
                <li>false (boolean)</li>
                <li>null (null-object)</li>
                <li>undefined (undefined)</li>
                <li>0 (number)</li>
                <li>NaN (number)</li>
                <li>"" (string)</li>
                <li>document.all (object)</li>
              </ol>
            </div>
            <div class="ex" id="arithmeticOpTF">
              <h3><a href="#arithmeticOp">산술연산자</a>로 진리값 확인하기</h3>
              <p>진리값을 산술연산자로 계산할 때 true(truthy)는 숫자 1, false(falsy)는 숫자 0으로 변환되어 계산됩니다.</p>
              <pre>
                <code>
                const x = true;
                const y = false;

                0 + x; // 1 
                0 + y; // 0
                "" + x; // true
                "" + y; // false
                false + x; // 1
                false + y; // 0
                null + x; // 1
                null + y; // 0
                undefined + x; // NaN
                undefined + y; // NaN</code>
              </pre>
            </div>
          </section>
          <section id="nullUndefined">
            <h2>빈값 Null & Undefined</h2>
            <p>null(No Value)과 undefined 모두 값이 없음을 나타내지만, 뜻이 약간  다릅니다. null은 "객체 값이 존재하지 않음"을 나타내고, undefined는 "아직 값을 지정한 적이 없음"을 나타냅니다. 그래서 typeof로 null을 반환하면 object로, undefined를 반환하면 undefined로 출력됩니다.</p>
            <pre>
              <code>
                typeof null; // object
                typeof undefined; // undefined</code>
            </pre>
            <div class="ex" id="nullUndefinedCheck">
              <h3>빈값 체크 Null & Undefiend Check</h3>
              <p><a href="#ifElse">if문</a>과 <a href="#typeOf">typeof</a>를 사용해서 변수값이 비어있는지(초기화되어있는지, 또는 지정된 적이 없는지) 확인할 수 있습니다. if문의 매개변수(parameter) 값은 진리값을 반환하므로 매개변수로 쓰인 변수값이 <a href="#truthyFalsy">truthy or falsy</a>값을 반환하면 빈값 여부를 알 수 있습니다.</p>
              <pre>
                <code>
                if (value) {
                  // value가 truthy라면 빈값이 아닙니다. (falsy 값입니다.)
                }</code>
              </pre>
              <p>어떠한 변수가 선언된 적이 있는지 잘 모를 때, 즉 변수가 이전에 선언된 적이 있는지 확인하고 싶을 때는 매개변수 안에 typeof 연산자를 추가한 뒤 엄격한 비교를 통해 undefined인지 확인합니다.<a href="http://typeofnan.blogspot.com/2011/01/typeof-is-fast.html">특히 undefined 체크에서 typeof 연산자를 사용하면 속도가 향상될 수 있다고 합니다.</a></p>
              <pre>
                <code>
                if (typeof value !== "undefined") {
                  // value의 타입이 undefined가 아니라면 value값은 선언된 적이 있습니다.
                }</code>
              </pre>
              <p>그런데 우리가 빈값이라고 생각하는 데이터타입이 null 또는 undefined가 아닌 경우가 많습니다. 아래에 헷갈릴 수 있는 데이터타입들을 모아봤습니다.</p>
              <pre>
                <code>
                typeof(); //undefined
                typeof(null); //null
                typeof(NaN); //number
                typeof(0); //number
                typeof({}); //object
                typeof([]); //array
                typeof(''); //string
                typeof(function () {}); //function
                typeof(/a/) //regexp
                typeof(new Date()) //date
                typeof(new WeakMap()) //weakmap
                typeof(new Map()) //map</code>
              </pre>
            </div>
          </section>
        </article>
        <article id="operators">
          <h1>연산자</h1>
          <p>JavaScript에서 주로 쓰이는 연산자는 아래와 같습니다.</p>
          <ol>
            <li><a href="#arithmeticOp">산술연산자</a></li>
            <li><a href="#assignmentOp">할당연산자</a></li>
            <li><a href="#comparisonOp">비교연산자</a></li>
            <li><a href="#logicalOp">논리연산자</a></li>
          </ol>
          <section id="arithmeticOp">
            <h2>산술연산자 Arithmetic Operators</h2>
            <p>산술연산자는 마치 계산기처럼 주로 간단한 숫자 계산을 할 때 사용하는 연산자입니다. 산술연산자는 숫자, 문자열, 또는 변수(variables)를 피연산자(operators)로 넣을 수 있고, 그 결과값을 숫자 또는 문자열로 반환합니다. 피연산자의 타입과 연산자의 종류에 따라 결과값의 타입이 달라집니다. 따라서 연산 전에 피연산자를 미리 <a href="#convertToNum">숫자로 변환</a>해두어야 일관적인 결과값을 얻을 수 있습니다.</p>
            <pre>
              <code>
                2 + 3 - 1; // 4
                5 * 3 / 2; // 15 / 2 
                // 7.5
                11 % 2 ** 3; // 11 % 8
                // 3</code>
            </pre>
            <div class="ex" id="addArith">
              <h3>덧셈 + Addition</h3>
              <p>덧셈은 숫자 뿐만아니라 다양한 데이터 타입끼리의 연산이 가능합니다. 문자열과 숫자를 연결할 때(Concatenation) 또는 문자열끼리 연결할 때, 그리고 진리값끼리 연산할 때에도 덧셈을 사용할 수 있습니다.</p>
              <pre>
                <code>
                0 + 1; // 1 
                0 + true; // 1 
                false + false; // 0 

                "Hi" + 5; // "Hi5"
                "Hi" + false; // "Hifalse"
                "Hi" + "Five"; // "HiFive"</code>
              </pre>
            </div>
            <div class="ex" id="subtArith">
              <h3>뺄셈 - Subtraction</h3>
              <p>뺄셈은 데이터끼리의 차이를 출력합니다. 덧셈을 제외한 나머지 산술연산에서는 문자열을 포함한 결과값이 NaN으로 출력됩니다.</p>             
              <pre>
                <code>
                0 - 1; // -1 
                0 - true; // -1 
                true - false; // 1 

                "Hi5" - 5; // NaN
                "Hifalse" - false; // NaN
                "HiFive" - "Five"; // NaN</code>
              </pre>
            </div>
            <div class="ex" id="multiArith">
              <h3>곱셈 * Multiplication</h3>
              <pre>
                <code>
                1 * 2; // 2
                1 * -2; // -2
                1 * 0; // 0
                Infinity * 0; // NaN
                Infinity * Infinity; // Infinity</code>
              </pre>
            </div>
            <div class="ex" id="divideArith">
              <h3>나눗셈 / Division</h3>
              <pre>
                <code>
                1 / 2; // 0.5
                1.0 / 2.0; // 0.5
                0 / 2; // 0
                2 / 0; // Infinity
                2.0 / 0.0; // Infinity
                2 / -0; // -Infinity</code>
              </pre>
            </div>
            <div class="ex" id="moduloArith">
              <h3>나머지 % Modulo(Remainder)</h3>
              <pre>
                <code>
                12 % 5; // 2
                1 % 2; // 1 
                -1 % 2; // -1
                1 % -2; // 1
                2 % 2; // 0
                -2 % 2; // -0
                0 % 2; // 0
                2 % 0; // NaN
                NaN % 2; // NaN
                5.5 % 2; // 1.5</code>
              </pre>
            </div>
            <div class="ex" id="exponentArith">
              <h3>거듭제곱 ** Exponentiation</h3>
              <p>JavaScript에서 거듭제곱을 사용할 때는 괄호 등으로 양음수 여부나 계산 순서를 명확히 해주어야 합니다.</p>
              <pre>
                <code>
                2 ** 3; // 8
                -2 ** 3; // Invalid
                -(2 ** 3); // -8
                (-2) ** 3; // 8

                3 ** 2.5 // 15.588457268119896
                10 ** -1 // 0.1
                NaN ** 2 // NaN

                2 ** 2 ** 3; // 128
                2 ** (2 ** 3) // 128
                (2 ** 2) ** 3 // 64</code>
              </pre>
            </div>
            <div class="ex" id="incre_decrementArith">
              <h3>증가 ++, 증감 -- Increment, Decrement</h3>
              <p>증가, 증감 연산자는 피연산자1의 뒤에 붙으면 피연산자2의 값을 계산 전 값으로 반환하고, 피연산자1의 앞에 붙으면 피연산자2의 값을 계산 후 값으로 반환합니다.</p>
              <pre>
                <code>
                let x = 5;
                y = x++; // x = 6, y = 5
                y = x--; // x = 4, y = 5
                // 연산자가 피연산자의 뒤에 붙었을 때

                let a = 5;
                b = ++a; // a = 6, b = 6
                b = --a; // a = 4, b = 4
                // 연산자가 피연산자의 뒤에 붙었을 때</code>
              </pre>
            </div>
          </section>
          <section id="assignmentOp">
            <h2>할당연산자 Assignment Operators</h2>
            <p>할당연산자는 연산자 기준으로 오른쪽 피연산자의 값을 왼쪽의 피연산자에 할당합니다.</p>
            <pre>
              <code>
                let a = 10;
                let b = 20;
                let c = 100;
                let d = 2000;
                let e = 45;

                a += 5; // 15
                b -= 30; // -10
                c *= 8; // 800
                d /= 50; // 40
                e %= 8; // 5</code>
            </pre>
            <div class="ex" id="equalAssign">
              <h3>할당 = Assignment</h3>
              <p>한 개의 값을 여러개의 변수에 할당하기 위해 할당 연산자를 연속으로 사용할 수 있습니다.</p>
              <pre>
                <code>
                let x = 5;
                let y = 10;
                let z = 25;

                x = y; // x = 10;</code>
              </pre>
            </div>
            <div class="ex" id="addAssign">
              <h3>덧셈 할당 += Addition Assignment</h3>
              <p>두개의 피연산자 데이터 타입에 따라 숫자의 덧셈 또는 문자열의 연결이 가능합니다.</p>
              <pre>
                <code>
                let str = "string";
                let num = 5;
                let boo = true;

                num += 2; // 7
                boo += 2; // 3
                boo += false; // 1
              
                num += "foo"; // "5foo"
                str += false; // "stringfalse"
                str += "foo"; // "stringfoo"</code>
              </pre>
            </div>
            <div class="ex" id="subtAssign">
              <h3>뺄셈 할당 -= Subtraction Assignment</h3>
              <pre>
                <code>
                let str = "string";
                let num = 5;
                let boo = true;

                num -= 2; // 3
                boo -= 2; // -1
                str -= 2; // NaN</code>
              </pre>
            </div>
            <div class="ex" id="multiAssign">
              <h3>곱셈 할당 *= Multiplication Assignment</h3>
              <pre>
                <code>
                let str = "string";
                let num = 5;
                let boo = true;

                num *= 2; // 10
                boo *= 2; // 2
                str *= 2; // NaN</code>
              </pre>
            </div>
            <div class="ex" id="divideAssign">
              <h3>나눗셈 할당 /= Division Assignment</h3>
              <pre>
                <code>
                let str = "string";
                let num = 5;
                let boo = true;

                num /= 2; // 2.5
                boo /= 2; // 0.5
                str /= 2; // NaN
                num /= 0; // Infinity</code>
              </pre>
            </div>
            <div class="ex" id="moduloAssign">
              <h3>나머지 할당 %= Modulo(Remainder) Assignment</h3>
              <pre>
                <code>
                let str = "string";
                let num = 5;
                let boo = true;

                num %= 2; // 1
                boo %= 2; // 1
                str %= 2; // NaN
                num %= 0; // Infinity</code>
              </pre>
            </div>
          </section>
          <section id="comparisonOp">
            <h2>비교연산자 Comparison Operators</h2>
            <p>서로 다른 두 값을 비교할 때 사용하는 비교연산자는 두 종류, 엄격한 비교(Strict Comparison)와 형변환 비교(Abstract Comparison)로 나뉜다. 엄격한 비교는 피연산자끼리 동일한 값과 데이터타입을 가져야만 true를 출력하고, 형변환은 비교 전 피연산자들을 같은 자료형으로 바꾼 뒤 엄격한 비교를 진행한다.<br>엄격한 비교연산자는 형변환 비교연산자의 뒤에 = 하나를 더 붙인다.</p>
            <div class="ex" id="equalityIdentity">
              <h3>동등 ==, 일치 === Equality, Identity</h3>
              <p>피연산자 둘 다 객체라면, 객체 내부 내용을 비교한 뒤 엄격한 비교를 진행한다. 단, null과 undefined는 엄격한 비교로서는 다르지만, 형변환 비교로는 같다.</p>
              <pre>
                <code>
                1 == 1
                "1" == 1
                0 == false // true

                0 == null
                0 == undefined // false

                1 === 1 // true
                1 === "1" // false

                null == undefined // true
                null === undefined // false</code>
              </pre>
            </div>
            <div class="ex" id="inequalityNonIdentity">
              <h3>부등 !=, 불일치 !== inequality, Non-Identity</h3>
              <pre>
                <code>
                1 != 2
                0 != true // true

                "1" != 1
                0 != false // false

                1 !== 2 // true
                "1" !== 1 // true</code>
              </pre>
            </div>
            <div class="ex" id="relationalOp">
              <h3>관계 >, <, >=, <= Relational Operators</h3>
              <pre>
                <code>
                3 > 3 
                3 < 3 // false

                3 >= 3
                3 <= 3 // true</code>
              </pre>
            </div>
          </section>
          <section id="logicalOp">
            <h2>논리연산자 Logical Operators</h2>
            <p>논리연산자는 진리값을 가진(또는 truthy & falsy 값을 반환하는) 두 피연산자의 집합을 관계지은 뒤, 주로 진리값 또는 다른 데이터형으로 출력합니다. 논리연산자가 포함된 논리표현식은 왼쪽부터 오른쪽 방향으로 진행됩니다.</p>
            <div class="ex" id="logicalAnd">
              <h3>&& AND</h3>
              <p>피연산자1이 false로 변환되면 피연산자1을 반환하고 표현식 진행을 종료합니다. 그렇지 않으면 피연산자2를 반환합니다.</p>
              <pre>
                <code>
                true && true // true (피연산자2)
                true && false // false 
                false && true // false 
                /*
                피연산자 둘 다 부울 타입인 경우
                */

                false && (3 === 4) // false (피연산자1)
                /*
                피연산자 중 하나가 부울 타입일 경우
                */

                "A" && "B" // "B"
                false && "B" // false (피연산자1)
                "A" && false // false (피연산자2)
                /*
                피연산자 중 하나가 부울 타입이고, 
                다른 하나는 문자열인 경우
                */

                "" && false // "" (피연산자1)
                false && "" // false (피연산자1)
                /*
                피연산자 중 하나가 부울 타입이고, 
                다른 하나는 빈 문자열인 경우
                */</code>
              </pre>
            </div>
            <div class="ex" id="logicalOr">
              <h3>|| OR</h3>
              <p>피연산자1이 true로 변환되면 피연산자1을 반환하고 표현식 진행을 종료합니다. 그렇지 않으면 피연산자2를 반환합니다.</p>
              <pre>
                <code>
                true || true // true (피연산자1)
                true || false // true 
                false || true // true
                /*
                피연산자 둘 다 부울 타입인 경우
                */

                false || (3 === 4) // false (피연산자2)
                /*
                피연산자 중 하나가 부울 타입일 경우
                */

                "A" || "B" // "A" (피연산자1)
                false || "B" // "B"
                "A" || false // "A"
                /*
                피연산자 중 하나가 부울 타입이고, 
                다른 하나는 문자열인 경우
                */

                "" || false // false (피연산자2)
                false || "" // "" (피연산자2)
                /*
                피연산자 중 하나가 부울 타입이고, 
                다른 하나는 빈 문자열인 경우
                */
                </code>
              </pre>
            </div>
            <div class="ex" id="logicalNot">
              <h3>!, !! NOT, Double NOT</h3>
              <p>Not은 단일 피연산자가 true로 변환되면 false를 반환합니다. 그렇지 않으면 true를 반환합니다. Double Not은 반대로 피연산자의 진리값을 그대로 반환합니다.</p>
              <pre>
                <code>
                !true // false
                !false // true
                !"" // true
                !"A" // false

                !!true // true
                !!false // false
                !!"" // false
                !!"A" // true</code>
              </pre>
            </div>
            <div class="ex" id="logicalExprShortC">
              <h3>논리표현식 단락 평가 Logical Expressions Short-circuit</h3>
              <p>논리연산자를 사용하는 논리표현식은 왼쪽부터 오른쪽 방향으로 진행되므로, 피연산자1에서 표현식 진행이 마무리 되면 다음 피연산자2를 계산할 필요가 없습니다. 따라서 되도록 계산을 빨리하기 위해 피연산자1만 계산하도록 하는 단락 평가를 수행합니다.</p>
              <pre>
                <code>
                function getA() {
                  console.log("A는 1");
                  return false;
                }
                function getB() {
                  console.log("B는 2");
                  return true;
                }

                console.log( getA() && getB() );
                // "A는 1"
                // false

                console.log( getB() || getA() );
                // "B는 2"
                // true
                
                /*
                논리표현식에서 피연산자1에서 계산이 완료되어 
                피연산자2를 계산하지 않음
                */</code>
              </pre>
            </div>
          </section>
        </article>
        <article id="object">
          <h1>객체</h1>
          <p>객체(object)는 마치 컨테이너 박스처럼 한꺼번에 여러 값을 담을 수 있는 구조를 지닌 데이터 타입입니다. 객체는 상당히 많은 기능을 갖고있기 때문에, JavaScript의 여러 기능들을 다루기 위해서는 객체에 대해 잘 알고있어야 합니다.</p>
          <section id="property">
            <h2>프로퍼티 Property</h2>
            <p>프로퍼티는 객체 안에서 변수처럼 이름 붙여지는 객체의 속성들입니다. 객체의 이름(name) 뒤에 .(점 연산자, dot operator)를 쓰고 프로퍼티를 붙입니다.</p>
            <pre>
              <code>
                const weather = "2019.04.14 Today: 날씨 맑음!!" 
                // weather은 객체의 이름입니다.

                weather.length; // 25
                // .length는 객체 안의 길이 속성을 출력하는 프로퍼티입니다.</code>
            </pre>
          </section>
          <section id="methods">
            <h2>메소드 Methods</h2>
            <p>메소드는 객체 안에서 쓰이는 함수입니다. 프로퍼티처럼 객체의 이름 뒤에 .(점 연산자)를 쓴 뒤에 메소드를 붙입니다.</p>
            <pre>
              <code>
                const weather = "2019.04.14 Today: 날씨 맑음!!" 
                // weather은 객체의 이름입니다.

                weather.charAt(6); // 4
                // .charAt()는 객체의 글자 순서를 변수에 맞춰 출력하는 함수, 메소드입니다.</code>
            </pre>
          </section>
          <!--<section id="built-inObj">
            <h2>내장객체 Built-in Objects</h2>
            <p>개발자가 새로운 객체를 직접 만들고 이름붙일 수 있지만, JavaScript에는 이미 내장된 객체들이 많이 있습니다.</p>
          </section>-->
        </article>
        <article id="conditionalStm">
          <h1>조건문</h1>
          <section id="ifElse">
            <h2>if & else</h2>
            <p>if문은 미리 지정된 변수를 자식개체로 삼아 ()에 넣고, 자식개체의 진리값(true & false, truthy & falsy)에 따라 어떤 행동을 출력할 지 {}에 적어냅니다. if문의 a값이 참이면 첫 번째 행동을, 거짓이면 else에 적힌 두 번째 행동을 출력합니다. 중간에 else if()를 추가해 조건을 여러 개 걸어놓을 수 있습니다.</p>
            <pre>
              <code>
                let a = true;

                if (a) {
                  console.log("a is true!");
                } else if(a == 0) {
                  console.log("a is zero!");
                } else {
                  console.log("a is false!")
                }

                // "a is true!"</code>
            </pre>
            <div class="ex" id="truthyFalsyAssignment">
              <h3>논리연산자를 이용한 조건문 Truthy & Falsy Assignment</h3>
              <p><a href="#logicalOr">논리연산자 ||(Or)</a>를 사용해 조건문을 만들 수 있습니다. ||는 왼쪽에서부터 오른쪽으로 진행되면서 true값을 반환합니다.</p>
              <pre>
                <code>
                let name = "";
                let userId = name || "익명의 사용자";

                console.log(`${userId}님이 로그인 하셨습니다.`);
                // "익명의 사용자님이 로그인하셨습니다."

                name = "Ujin";
                userId = name || "익명의 사용자";
                
                console.log(`${userId}님이 로그인 하셨습니다.`);
                // "Ujin님이 로그인하셨습니다."</code>
              </pre>
            </div>
            <div class="ex" id="ternaryOp">
              <h3>삼항 연산자 ternary Operator</h3>
              <p>삼항 연산자는 세 개의 피연산 함수를 쓸 수 있는 연산자입니다. 조건이 true이면 ? 피연산자1을, : 아니라면 피연산자2를 반환합니다.</p>
              <pre>
                <code>
                let name = "";
                let userId = name || "익명의 사용자";

                name ? console.log(`${userId}님, 안녕하세요!`) : console.log(`로그인이 필요합니다.`);</code>
              </pre>
            </div>
          </section>
          <section id="switch">
            <h2>switch</h2>
            <p>조건문의 조건이 단일의 숫자나 문자열처럼 비교적 단순한 구조라면 switch문으로 더욱 간단하게 표현할 수 있습니다. switch문에서는 각 조건(case)이 끝날 때마다 break;를 반드시 써야합니다.</p>
            <pre>
              <code>
                let name = "";
                let weather;

                switch (weather) {
                  case "sunny":
                    console.log("Great to walk!");
                    break;
                  case "gloomy":
                    console.log("Not so bad.");
                    break;
                  case "rainy":
                    console.log("Take your umbrella!");
                    break;
                  default:
                    console.log("How"s the weather outside?");
                    break;
                }</code>
            </pre>
          </section>
        </article>
        <article id="functions">
          <h1>함수</h1>
          <p>함수는 문서 내에서 특별한 역할을 수행하는 명령문을 한데 모은 블록문이며, 데이터 타입은 Function-객체입니다. 함수는  키워드 function 으로 정의한 뒤 함수명 식별자(identifier), 함수 안에서 쓰일 인수(parameter), 함수 안의 실행문(statements)으로 구성됩니다.</p>
          <p>함수는 기본값으로 undefined를 갖고있지만, 특정한 값을 반환하고 싶다면 return 문이 함수 끝에 있어야 합니다.</p>
          <pre>
            <code>
                function funcA() {
                  console.log("Function A is working!");
                }
                funcA(); // "Function A is working!"
                /*
                function 기본문
                */

                function getArea(width, height) {
                  console.log(width * height);
                }
                getArea(60, 20); // 1200
                /*
                function 기본문 + param
                */

                function timeFlies(year){
                  yearAgo = year - 1; 
                  return yearAgo;
                }
                timeFlies(); // if (year = 2019) {yearAgo = 2018}
                /*
                function 기본문 + param + return
                */</code>
          </pre>
          <section id="functionDefinition">
            <h2>함수 정의 (ES6) Function Definition</h2>
            <p>아래의 예제들은 함수를 더욱 간단하게 쓸 수 있도록 ES6 이후 등장한 함수 정의 방법들입니다. 그러나 브라우저간 호환성 문제가 있기 때문에 로컬 작업에만 사용할 것을 권장합니다.</p>
            <div class="ex" id="functionExpr">
              <h3>함수표현식 Function Expressions</h3>
              <p>함수표현식의 문법은 함수 기본문과 거의 같습니다. 앞에 정의 키워드로 식별자를 선언한 뒤, function 키워드를 param 앞에 붙입니다.</p>
              <pre>
                <code>
                var getArea = function(width, height) {
                  var area = width * height;
                  return area;
                }</code>
              </pre>
            </div>
            <div class="ex" id="functionArrow">
              <h3>화살표 함수식 Arrow Function Notation</h3>
              <p>함수표현식에서 function 키워드가 arrow로 바뀌고, arrow는 param 뒤에 붙습니다.</p>
              <pre>
                <code>
                var getArea = (width, height) => {
                  var area = width * height;
                  return area;
                }</code>
              </pre>
            </div>
            <div class="ex" id="functionConciseArrow">
              <h3>축약 화살표 함수식 Concise Arrow Notation</h3>
              <p>더욱 축약된 함수식은 함수 내에 따로 return값을 정의하지 않고도 함수값을 출력합니다.</p>
              <pre>
                <code>
                var getArea = (width, height) => {
                  var area = width * height;
                  return area;
                }
                /*
                이 함수식은 아래와 같습니다.
                */

                var getArea = (width, height) => width * height;</code>
              </pre>
            </div>
          </section>
        </article>
        <!--<article id="arrays"></article>-->
      </main>
      <footer>
        <div class="footer-contents">
          <p>Referenced by Codecademy, MDN, and StackOverflow<br>
          Written & Edited by Lee Ujin</p>
        </div>
      </footer>
    </div>
  </body>
</html>